<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gorse Document</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-recommend.html"><strong aria-hidden="true">1.2.</strong> Recommend using Gorse</a></li><li class="chapter-item expanded "><a href="ch01-03-config.html"><strong aria-hidden="true">1.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="ch01-04-demo.html"><strong aria-hidden="true">1.4.</strong> GitRec, The Live Demo</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2: Build Recommender</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-items.html"><strong aria-hidden="true">2.1.</strong> Item Management</a></li><li class="chapter-item expanded "><a href="ch02-02-feedback.html"><strong aria-hidden="true">2.2.</strong> Feedback Collection</a></li><li class="chapter-item expanded "><a href="ch02-03-strategy.html"><strong aria-hidden="true">2.3.</strong> Recommendation Strategies</a></li><li class="chapter-item expanded "><a href="ch02-04-performance.html"><strong aria-hidden="true">2.4.</strong> Performance vs Precision</a></li><li class="chapter-item expanded "><a href="ch02-05-dashboard.html"><strong aria-hidden="true">2.5.</strong> Gorse Dashboard</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: Monitoring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-logging.html"><strong aria-hidden="true">3.1.</strong> Log Monitoring</a></li><li class="chapter-item expanded "><a href="ch03-02-metrics.html"><strong aria-hidden="true">3.2.</strong> Metrics Monitoring</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Chapter 4: Developer's Guide</a></li><li class="chapter-item expanded affix "><a href="faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gorse Document</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-quick-start"><a class="header" href="#chapter-1-quick-start">Chapter 1: Quick Start</a></h1>
<p>Gorse is an open-source recommendation system written in Go. Gorse aims to be a universal open-source recommender system that can be easily introduced into a wide variety of online services. By importing items, users, and interaction data into Gorse, the system will automatically train models to generate recommendations for each user. Project features are as follows.</p>
<ul>
<li><strong>AutoML</strong>: Choose the best recommendation model and strategy automatically by model searching in the background.</li>
<li><strong>Distributed Recommendation</strong>: Single node training, distributed prediction, and ability to achieve horizontal scaling in the recommendation stage.</li>
<li><strong>RESTful API</strong>: Provide RESTful APIs for data CRUD and recommendation requests.</li>
<li><strong>Dashboard</strong>: Provide dashboard for data import and export, monitoring, and cluster status checking.</li>
</ul>
<p>Gorse is a single node training and distributed prediction recommender system. Gorse stores data in MySQL or MongoDB, with intermediate data cached in Redis. The cluster consists of a master node, multiple worker nodes, and server nodes. The master node is responsible for model training, non-personalized item recommendation, configuration management, and membership management. The server node is responsible for exposing the RESTful APIs and online real-time recommendations. Worker nodes are responsible for the offline recommendation for each user. In addition, the administrator can perform system monitoring, data import and export, and system status checking via the dashboard on the master node.</p>
<center><img width=480 src="img/architecture.png"/></center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Gorse can be set up via Docker Compose or manually.</p>
<h2 id="setup-gorse-with-docker-compose"><a class="header" href="#setup-gorse-with-docker-compose">Setup Gorse with Docker Compose</a></h2>
<p>The best practice to manage Gorse nodes is using orchestration tools such as Docker Compose, etc. There are Docker images of the master node, the server node, and the worker node.</p>
<table><thead><tr><th>Docker Image</th><th>Image Size</th></tr></thead><tbody>
<tr><td>gorse-master</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-master"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-master" alt="gorse-master" /></a></td></tr>
<tr><td>gorse-server</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-server"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-server" alt="gorse-server" /></a></td></tr>
<tr><td>gorse-worker</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-worker"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-worker" alt="gorse-worker" /></a></td></tr>
</tbody></table>
<p>There is an example <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/docker-compose.yml">docker-compose.yml</a> consists of a master node, a server node and a worker node, a Redis instance, and a MySQL instance.</p>
<ul>
<li>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">config.toml</a> (Docker Compose version) in the working directory.</li>
<li>Setup the Gorse cluster using Docker Compose.</li>
</ul>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import it to the MySQL instance.</li>
</ul>
<pre><code class="language-bash">mysql -h 127.0.0.1 -u root -proot_pass gorse &lt; github.sql
</code></pre>
<ul>
<li>Restart the master node to apply imported data.</li>
</ul>
<pre><code class="language-bash">docker-compose restart
</code></pre>
<p>These images tagged with the <code>latest</code> tag are built from the master branch. The <code>tag</code> should be fixed to a specified version in production.</p>
<h2 id="setup-gorse-manually"><a class="header" href="#setup-gorse-manually">Setup Gorse Manually</a></h2>
<p>Binary distributions have been provided for 64-bit Windows/Linux/Mac OS on the <a href="https://github.com/zhenghaoz/gorse/releases">release</a> page. Due to the demand for large memories, 64-bit machines are highly recommended to deploy Gorse.</p>
<p>Gorse depends on the following software:</p>
<table><thead><tr><th>Software</th><th>Role</th></tr></thead><tbody>
<tr><td><em>Redis</em></td><td>used to store caches.</td></tr>
<tr><td><em>MySQL/MongoDB</em></td><td>used to store data.</td></tr>
</tbody></table>
<ul>
<li>Install Gorse</li>
</ul>
<p><strong>Option 1:</strong> Download binary distributions (Linux)</p>
<pre><code class="language-bash">wget https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_linux_amd64.zip
unzip gorse_linux_amd64.zip
</code></pre>
<p>For Windows and MacOS (Intel Chip or Apple Silicon), download <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_windows_amd64.zip">gorse_windows_amd64.zip</a>, <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_amd64.zip">gorse_darwin_amd64.zip</a> or <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_arm64.zip">gorse_darwin_arm64.zip</a> respectively.</p>
<p><strong>Option 2:</strong> Build executable files via <code>go get</code></p>
<pre><code class="language-bash">go get github.com/zhenghaoz/gorse/...
</code></pre>
<p>Built binaries locate at <code>$(go env GOPATH)/bin</code>.</p>
<ul>
<li>Configuration</li>
</ul>
<p>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a> in the working directory. Set <code>cache_store</code> and <code>data_store</code> in the configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a>.</p>
<pre><code class="language-toml"># This section declares settings for the database.
[database]

# database for caching (support Redis only)
cache_store = &quot;redis://localhost:6379&quot;

# database for persist data (support MySQL/MongoDB)
data_store = &quot;mysql://root@tcp(localhost:3306)/gorse?parseTime=true&quot;
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import it to the MySQL instance.</li>
</ul>
<pre><code class="language-bash">mysql -h 127.0.0.1 -u root gorse &lt; github.sql
</code></pre>
<ul>
<li>Start the master node</li>
</ul>
<pre><code class="language-bash">./gorse-master -c config.toml
</code></pre>
<p><code>-c</code> specifies the path of the configuration file.</p>
<ul>
<li>Start the server node and worker node</li>
</ul>
<pre><code class="language-bash">./gorse-server --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8087
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for RESTful APIs and metrics reporting of this server node.</p>
<pre><code class="language-bash">./gorse-worker --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8089 -j 4
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for metrics reporting of this worker node. <code>-j</code> is the number of working threads.</p>
<h2 id="play-with-gorse"><a class="header" href="#play-with-gorse">Play with Gorse</a></h2>
<p>There are HTTP entries provided by Gorse:</p>
<table><thead><tr><th>Entry</th><th>Link</th></tr></thead><tbody>
<tr><td>Master Dashboard</td><td>http://127.0.0.1:8088/</td></tr>
<tr><td>Server RESTful API</td><td>http://127.0.0.1:8087/apidocs</td></tr>
<tr><td>Server Prometheus Metrics</td><td>http://127.0.0.1:8087/metrics</td></tr>
<tr><td>Worker Prometheus Metrics</td><td>http://127.0.0.1:8089/metrics</td></tr>
</tbody></table>
<h3 id="master-dashboard"><a class="header" href="#master-dashboard">Master Dashboard</a></h3>
<p><img src="img/dashboard.jpg" alt="dashboard" /></p>
<h3 id="server-restful-api"><a class="header" href="#server-restful-api">Server RESTful API</a></h3>
<p><img src="img/swagger.png" alt="swagger" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommend-using-gorse"><a class="header" href="#recommend-using-gorse">Recommend using Gorse</a></h1>
<p>Each component and concept of Gorse will be introduced in this section.</p>
<h2 id="users-items-and-feedback"><a class="header" href="#users-items-and-feedback">Users, Items, and Feedback</a></h2>
<p>A recommender system is expected to recommend items to users. To learn the preferences of each user, feedbacks between users and items are fed to the recommender system. In Gorse, there are three types of entities.</p>
<ul>
<li><strong>User:</strong> A user is identified by a string identifier.</li>
</ul>
<pre><code class="language-go">type User struct {
  UserId    string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item is identified by a string identifier. A timestamp is used to record the freshness of this item. The timestamp could be the last update time, release time, etc. Labels are used to describe characters of this item, eg., tags of a movie.</li>
</ul>
<pre><code class="language-go">type Item struct {
  ItemId    string
  Timestamp time.Time
  Labels    []string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback is identified a triple: feedback type, user ID, and item ID. The type of feedback can be positive (like), negative (dislike), or neutral (read). The timestamp record the time that this feedback happened.</li>
</ul>
<pre><code class="language-go">type Feedback struct {
  FeedbackType string
  UserId       string
  ItemId       string
  Timestamp   time.Time
}
</code></pre>
<p>Types of feedbacks are classified into three categories:</p>
<ol>
<li><code>positive_feedback_types</code> mean a user favors an item.</li>
<li><code>click_feedback_types</code> mean a user favors a recommended item. This item must be recommended by Gorse.</li>
<li><code>read_feedback_type</code> means a user reads an item. However, the real feedback this user has in his/her mind is never known.</li>
</ol>
<p>The difference between <code>positive_feedback_types</code> and <code>click_feedback_types</code> is that the item of <code>click_feedback_types</code> must come from recommendations of Gorse. The item of <code>positive_feedback_types</code> could be found by a user through other approaches such as search, direct access, etc. <code>read_feedback_type</code> is a neutral event. Negative feedback can be conduct by {<code>read_feedback_type</code> items} - {<code>positive_feedback_types</code> items}.</p>
<blockquote>
<p>There might be an extra field in the defined structure. They are preserved for future usage.</p>
</blockquote>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<p>The main workflow of Gorse is as follows:</p>
<center><img width=480 src="img/workflow.png"/></center>
<ol>
<li>Feedbacks generated by users are collected to the data store.</li>
<li>Archived feedbacks are pulled to train the recommender model. There are two types of models (ranking model and CTR model) in Gorse, they are treated as one here.</li>
<li>Offline recommendations are generated in the background from all items and cached.</li>
<li>Online recommendations are returned to users in real-time based on cached offline recommendations.</li>
</ol>
<h2 id="data-storage"><a class="header" href="#data-storage">Data Storage</a></h2>
<p>There are two types of storage used in Gorse: data store and cache-store.</p>
<h3 id="data-store"><a class="header" href="#data-store">Data Store</a></h3>
<p>The <code>data_store</code> is used to store items, users, feedbacks, and measurements. Currently, MySQL and MongoDB are supported as data storage. Other databases will be available once its interface is implemented.</p>
<p>Unfortunately, there are two challenges in data storage:</p>
<ol>
<li>
<p>What if feedback with an unknown user or item is inserted? There are two options <code>auto_insert_user</code> and <code>auto_insert_item</code> to control feedback insertion. If new users or items insertion is forbidden, feedback with new users or items will be ignored.</p>
</li>
<li>
<p>How to address stale feedback and items? Some items and their feedbacks are short-lived such as news. <code>positive_feedback_ttl</code> and <code>item_ttl</code> are used to ignore stale feedback and items when pulling datasets from a data store.</p>
</li>
</ol>
<h3 id="cache-store"><a class="header" href="#cache-store">Cache-Store</a></h3>
<p>The <code>cache_store</code> is used to store offline recommendation and temp variables. Only Redis is supported. The latest items, popular items, similar items, and recommended items are cached in Redis. The length of each cached list is <code>cache_size</code>.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Recommended items come from multiple sources through multiple stages. Non-personalized recommendations (popular/latest/similar) are generated by the master node. Offline personalized recommendations are generated by worker nodes while online personalized recommendations are generated by server nodes.</p>
<h3 id="popular-items"><a class="header" href="#popular-items">Popular Items</a></h3>
<p>Items with the maximum number of users will be collected. To avoid popular items resist on the top list, <code>popular_window</code> restricts that timestamps of collected items must be after <code>popular_window</code> days ago. There will be no timestamp restriction if <code>popular_window</code> is <code>0</code>.</p>
<h3 id="latest-items"><a class="header" href="#latest-items">Latest Items</a></h3>
<p>Items with the latest timestamps are collected. Items won't be added to the latest items collection if their timestamp is empty.</p>
<h3 id="similar-items"><a class="header" href="#similar-items">Similar Items</a></h3>
<p>For each item, top n (n equals <code>cache_size</code>) similar items are collected. In the current implementation, the similarity between items is the number of common users of two items<sup class="footnote-reference"><a href="#6">1</a></sup>.</p>
<h3 id="offline-recommendation"><a class="header" href="#offline-recommendation">Offline Recommendation</a></h3>
<p>Worker nodes collect top n items from all items and save them to cache. Besides, the latest items are added to address the cold-start problem in the recommender system. When labels of items exist, the CTR prediction model is enabled, vice versa. The procedure of offline recommendation is different depending on whether the CTR mode is enabled.</p>
<p><strong>If the CTR model is enabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of current users using the ranking model.</li>
<li>Append <code>explore_latest_num</code> latest items to the collection.</li>
<li>Rerank collected items using the CTR prediction model.</li>
</ol>
<p><strong>If the CTR model is disabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of current users using the ranking model.</li>
<li>Insert <code>explore_latest_num</code> latest items to random positions in the collection.</li>
</ol>
<p>Offline recommendation cache will be consumed by users and fashion will change. The offline recommendation will be refreshed under one of these two conditions:</p>
<ul>
<li>The timestamp of offline recommendation has been <code>refresh_recommend_period</code> days ago.</li>
<li>New feedbacks have been inserted since the timestamp of the offline recommendation.</li>
</ul>
<p>There are 4 ranking models (BPR<sup class="footnote-reference"><a href="#5">2</a></sup>/ALS<sup class="footnote-reference"><a href="#3">3</a></sup>/CCD<sup class="footnote-reference"><a href="#4">4</a></sup>) and 1 CTR model (factorization machines<sup class="footnote-reference"><a href="#2">5</a></sup>) in Gorse. They will be applied automatically by the model searcher. In ranking models, items and users are represented as embedding vectors. Since the dot product between two vectors is fast, ranking models are used to find top N items among all items. In CTR models, features from users or items are used in prediction. It's expensive to use CTR models to predict scores of all items.</p>
<h3 id="online-recommendation"><a class="header" href="#online-recommendation">Online Recommendation</a></h3>
<p>The online recommendation in the server node consists of three stages:</p>
<ol>
<li>Load offline recommendations from the cache, remove read items.</li>
<li>If the number of offline recommendations is less than required, collect items similar to these items in the user's historical feedbacks. Read items are removed as well.</li>
<li>If the number of recommendations is still less than required, collect items from <code>fallback_recommend</code> (latest items or popular items). Read items are removed.</li>
</ol>
<h2 id="model-update"><a class="header" href="#model-update">Model Update</a></h2>
<p>There are two kinds of models in Gorse, but the training and hyperparameters optimization procedures are quite the same.</p>
<h3 id="model-training"><a class="header" href="#model-training">Model Training</a></h3>
<p>Model training is done by the master node, as well as model search. The master node pulls data from the database and fits the ranking model and CTR model periodically.</p>
<blockquote>
<ul>
<li>For every <code>fit_jobs</code> minutes:
<ul>
<li>Pull data from database.
<ul>
<li>Train model with hyperparameters found by model search using <code>fit_jobs</code> jobs.</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="model-search"><a class="header" href="#model-search">Model Search</a></h3>
<p>There are many hyperparameters for each recommendation model in Gorse. However, it is hard to configure these hyperparameters manually even for machine learning experts. To help users get rid of hyperparameters tuning, Gorse integrates random search<sup class="footnote-reference"><a href="#1">6</a></sup> for hyperparameters optimization. The procedure of model search is as follows:</p>
<blockquote>
<ul>
<li>For every <code>search_period</code> minutes:
<ul>
<li>Pull data from database.</li>
<li>For every recommender models:
<ul>
<li>For <code>search_trials</code> trials:
<ul>
<li>Sample a hyperparameter combination.</li>
<li>Train model with sampled hyperparameters by <code>search_epoch</code> epoches and <code>search_jobs</code> jobs.</li>
<li>Update best model.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="online-evaluation"><a class="header" href="#online-evaluation">Online Evaluation</a></h2>
<p>The only method to estimate recommendation performance is online evaluation. The metric of online evaluation in Gorse is click-through-rate: <code>click feedback</code> / <code>read feedback</code>.</p>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">1</sup>
<p>Zhang, Zhenghao, et al. &quot;SANS: Setwise Attentional Neural Similarity Method for Few-Shot Recommendation.&quot; DASFAA (3). 2021.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">2</sup>
<p>Rendle, Steffen, et al. &quot;BPR: Bayesian personalized ranking from implicit feedback.&quot; Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence. 2009.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Hu, Yifan, Yehuda Koren, and Chris Volinsky. &quot;Collaborative filtering for implicit feedback datasets.&quot; <em>2008 Eighth IEEE International Conference on Data Mining</em>. Ieee, 2008.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>He, Xiangnan, et al. &quot;Fast matrix factorization for online recommendation with implicit feedback.&quot; Proceedings of the 39th International ACM SIGIR conference on Research and Development in Information Retrieval. 2016.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">5</sup>
<p>Rendle, Steffen. &quot;Factorization machines.&quot; <em>2010 IEEE International Conference on Data Mining</em>. IEEE, 2010.</p>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">6</sup>
<p>Bergstra, James, and Yoshua Bengio. &quot;Random search for hyper-parameter optimization.&quot; Journal of machine learning research 13.2 (2012).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Previous section <em><a href="ch01-02-recommend.html">Recommend using Gorse</a></em> is helpful to understand configurations introduced in this section. These configuration items without default values must be filled. It's highly recommended to create a new config file based on <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template"><code>config.toml.template</code></a>.</p>
<h2 id="database"><a class="header" href="#database"><code>[database]</code></a></h2>
<p>Configurations under <code>[database]</code> are used to define behaviors on the database and data.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data_store</code></td><td>string</td><td></td><td>Database for data store (supports MySQL/MongoDB)</td></tr>
<tr><td><code>cache_store</code></td><td>string</td><td></td><td>Database for cache store (supports Redis)</td></tr>
<tr><td><code>auto_insert_user</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new users when inserting new feedback <a href="ch02-02-feedback.html#users-items-and-feedback">(2.2)</a></td></tr>
<tr><td><code>auto_insert_item</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new items when inserting new feedback <a href="ch02-02-feedback.html#users-items-and-feedback">(2.2)</a></td></tr>
<tr><td><code>cache_size</code></td><td>string</td><td><code>100</code></td><td>Number of cached elements in cache store</td></tr>
<tr><td><code>positive_feedback_types</code></td><td>string</td><td></td><td>Types of positive feedback <a href="ch02-02-feedback.html#define-positive-feedback-and-read-feedback">(2.2)</a></td></tr>
<tr><td><code>read_feedback_type</code></td><td>string</td><td></td><td>Type of feedback for read events <a href="ch02-02-feedback.html#define-positive-feedback-and-read-feedback">(2.2)</a></td></tr>
<tr><td><code>positive_feedback_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of positive feedback</td></tr>
<tr><td><code>item_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of items</td></tr>
</tbody></table>
<p>The DSN (Database Source Name) format of the <code>data_store</code> and <code>cache_store</code> is as follows.</p>
<ul>
<li>Redis: <code>redis://hostname:port</code></li>
<li>MySQL: <code>mysql://[username[:password]@][protocol[(hostname:port)]]/database[?config1=value1&amp;...configN=valueN]</code></li>
<li>PostgresSQL: <code>postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full</code></li>
<li>ClickHouse: <code>clickhouse://user:password@host[:port]/database?param1=value1&amp;...&amp;paramN=valueN</code></li>
<li>MongoDB: <code>mongodb://[username:password@]hostname1[:port1][,... hostnameN[:portN]]][/[database][?options]]</code></li>
</ul>
<h2 id="master"><a class="header" href="#master"><code>[master]</code></a></h2>
<p>Configurations under <code>[master]</code> are used to define behaviors of the master node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td><code>&quot;127.0.0.1&quot;</code></td><td>Master node listening host for gRPC service (metadata exchange)</td></tr>
<tr><td><code>port</code></td><td>integer</td><td><code>8086</code></td><td>Master node listening port for gRPC service (metadata exchange)</td></tr>
<tr><td><code>http_host</code></td><td>string</td><td><code>&quot;127.0.0.1&quot;</code></td><td>Master node listening host for HTTP service (dashboard)</td></tr>
<tr><td><code>http_port</code></td><td>integer</td><td><code>8088</code></td><td>Master node listening port for HTTP service (dashboard)</td></tr>
<tr><td><code>n_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for the master node</td></tr>
<tr><td><code>meta_timeout</code></td><td>integer</td><td><code>60</code></td><td>Metadata timeout in seconds</td></tr>
<tr><td><code>dashboard_user_name</code></td><td>string</td><td></td><td>Username login dashboard</td></tr>
<tr><td><code>dashboard_password</code></td><td>string</td><td></td><td>Password login dashboard</td></tr>
</tbody></table>
<h2 id="server"><a class="header" href="#server"><code>[server]</code></a></h2>
<p>Configurations under <code>[server]</code> are used to define behaviors of the server node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default_n</code></td><td>integer</td><td><code>10</code></td><td>Default number of returned items</td></tr>
<tr><td><code>api_key</code></td><td>string</td><td></td><td>Secret key for RESTful APIs (SSL required)</td></tr>
</tbody></table>
<h2 id="recommend"><a class="header" href="#recommend"><code>[recommend]</code></a></h2>
<p>Configurations under <code>[recommend]</code> are used to define behaviors of recommendation.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>popular_window</code></td><td>integer</td><td><code>180</code></td><td>Time window of popular items in days <a href="ch02-03-strategy.html#latest-recommender">(2.3)</a></td></tr>
<tr><td><code>fit_period</code></td><td>integer</td><td><code>60</code></td><td>Period of model training in minutes</td></tr>
<tr><td><code>search_period</code></td><td>integer</td><td><code>180</code></td><td>Period of model search in minutes</td></tr>
<tr><td><code>search_epoch</code></td><td>integer</td><td><code>100</code></td><td>Number of training epochs for each model in model search</td></tr>
<tr><td><code>search_trials</code></td><td>integer</td><td><code>10</code></td><td>Number of trials for each model in model search</td></tr>
<tr><td><code>refresh_recommend_period</code></td><td>integer</td><td><code>5</code></td><td>Period to refresh offline recommendation cache in days</td></tr>
<tr><td><code>fallback_recommend</code></td><td>strings</td><td><code>[&quot;latest&quot;]</code></td><td>Source of recommendation when personalized recommendation exhausted <a href="ch02-03-strategy.html#online-strategy">(2.3)</a></td></tr>
<tr><td><code>num_feedback_fallback_item_based</code></td><td>integer</td><td><code>10</code></td><td>The number of feedback used in fallback item-based similar recommendation <a href="ch02-03-strategy.html#online-strategy">(2.3)</a></td></tr>
<tr><td><code>item_neighbor_type</code></td><td>string</td><td><code>&quot;auto&quot;</code></td><td>The type of neighbors for items <a href="ch02-03-strategy.html#item-based-similarity-recommender">(2.3)</a></td></tr>
<tr><td><code>enable_item_neighbor_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate item neighbor searching using vector index</td></tr>
<tr><td><code>item_neighbor_index_recall</code></td><td>float</td><td><code>0.8</code></td><td>Minimal recall for approximate user neighbor searching</td></tr>
<tr><td><code>item_neighbor_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate user neighbor searching vector index</td></tr>
<tr><td><code>user_neighbor_type</code></td><td>string</td><td><code>&quot;auto&quot;</code></td><td>The type of neighbors for users <a href="ch02-03-strategy.html#user-based-similarity-recommender">(2.3)</a></td></tr>
<tr><td><code>enable_user_neighbor_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate item neighbor searching using vector index</td></tr>
<tr><td><code>user_neighbor_index_recall</code></td><td>float</td><td><code>0.8</code></td><td>Minimal recall for approximate item neighbor searching</td></tr>
<tr><td><code>user_neighbor_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate item neighbor searching vector index</td></tr>
<tr><td><code>enable_latest_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable latest recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_popular_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable popular recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_user_based_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable user-based similarity recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_item_based_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable item-based similarity recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_collaborative_recommend</code></td><td>boolean</td><td><code>true</code></td><td>Enable collaborative filtering recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_collaborative_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate collaborative filtering recommend using vector index</td></tr>
<tr><td><code>collaborative_index_recall</code></td><td>float</td><td><code>0.9</code></td><td>Minimal recall for approximate collaborative filtering recommend</td></tr>
<tr><td><code>collaborative_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate collaborative filtering recommend vector index</td></tr>
<tr><td><code>enable_click_through_prediction</code></td><td>boolean</td><td><code>false</code></td><td>Enable click-though rate prediction during offline recommendation. Otherwise, results from multi-way recommendation would be merged randomly <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>explore_recommend</code></td><td>map</td><td><code>{ popular = 0.0, latest = 0.0 }</code></td><td>The explore recommendation method is used to inject popular items or latest items into recommended result <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitrec-the-live-demo"><a class="header" href="#gitrec-the-live-demo">GitRec, The Live Demo</a></h1>
<p><a href="https://gitrec.gorse.io/">GitRec</a>, the live demo, is developed to demonstrate the usage of the Gorse recommender system engine. A user logins in via GitHub OAuth, then repositories starred by this user before being imported to Gorse. Gorse recommends repositories to this user based on starred repositories. When this user saw a recommended repository, he or she can press ❤️ to tell GitRec that he or she like this recommendation and press ⏯️ to skip the current recommendation.</p>
<p><img src="img/gitrec.jpg" alt="gitrec" /></p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<center><img width="500" src="img/gitrec-architecture.png"/></center>
<ul>
<li><strong>Import new repositories</strong>: The trending crawler crawls trending repositories and inserts them into Gorse as new items. Since there are a huge number of repositories in GitHub, it's impossible to add all of them into GitRec. So, only trending repositories are imported.</li>
<li><strong>Import user starred repositories</strong>: The user starred crawler crawls user starred repositories and inserts them into Gorse as new feedback typed <code>star</code> when a new user signed in.</li>
<li><strong>Recommendation and feedbacks</strong>: GitRec web service pulls recommendations from Gorse and shows them to users. When a user press ❤️, the <code>like</code> feedback type will be inserted to Gorse. When ⏯️ pressed, <code>view</code> feedback type will be inserted to Gorse.</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>In GitRec, there are three types of feedbacks: <code>read</code>, <code>star</code> and <code>like</code>. <code>read</code> is the feedback type for reading events (a user skip a recommended repository). <code>like</code> is the feedback type for user press ❤️. <code>star</code> is the feedback type for user starred repositories. Since <code>star</code> events don't happen in GitRec, it won't be added to <code>click_feedback_types</code>.</p>
<pre><code class="language-toml"># feedback type for positive event
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# feedback type for read event
read_feedback_type = &quot;read&quot;
</code></pre>
<p>Other settings are the same as <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">docker/config.toml</a>.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>This project consists of frontend, backend, and crawlers. In this section, only these codes that interact with Gorse are introduced. Other codes are available in the <a href="https://github.com/zhenghaoz/gitrec">GitRec repository</a>.</p>
<ol>
<li>
<p>First thing is to wrap Gorse API as a python module. It sends HTTP requests and handles responses using <code>requests</code>.</p>
<pre><code class="language-python">from collections import namedtuple
from datetime import datetime
from typing import List

import requests

Success = namedtuple(&quot;Success&quot;, [&quot;RowAffected&quot;])


class GorseException(BaseException):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message


class Gorse:
    def __init__(self, entry_point):
        self.entry_point = entry_point

    def insert_feedback(
        self, feedback_type: str, user_id: str, item_id: str
    ) -&gt; Success:
        r = requests.post(
            self.entry_point + &quot;/api/feedback&quot;,
            json=[
                {
                    &quot;FeedbackType&quot;: feedback_type,
                    &quot;UserId&quot;: user_id,
                    &quot;ItemId&quot;: item_id,
                    &quot;Timestamp&quot;: datetime.now().isoformat(),
                }
            ],
        )
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def get_recommend(self, user_id: str, n: int = 1) -&gt; List[str]:
        r = requests.get(self.entry_point + &quot;/api/recommend/%s?n=%d&quot; % (user_id, n))
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_feedbacks(self, feedbacks) -&gt; Success:
        r = requests.post(self.entry_point + &quot;/api/feedback&quot;, json=feedbacks)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_item(self, item) -&gt; List[str]:
        r = requests.post(self.entry_point + &quot;/api/item&quot;, json=item)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)
</code></pre>
</li>
<li>
<p>In the code of trending crawler, insert trending repositories as new items.</p>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    trending_repos = get_trending()
    for trending_repo in trending_repos:
        gorse_client.insert_item(get_repo_info(trending_repo))
</code></pre>
</li>
<li>
<p>In the code of starred repositories crawler, insert user starred repositories as <code>star</code> feedbacks.</p>
<pre><code class="language-python">@app.task
def pull(token: str):
    g = GraphQLGitHub(token)
    stars = g.get_viewer_starred()
    gorse_client.insert_feedbacks(stars)
</code></pre>
</li>
<li>
<p>In the code of the web service backend, pull recommendations from Gorse, insert <code>like</code> and <code>read</code> into Gorse.</p>
<pre><code class="language-python">@app.route(&quot;/api/repo&quot;)
def get_repo():
    repo_id = gorse_client.get_recommend(session[&quot;user_id&quot;])[0]
    full_name = repo_id.replace(&quot;:&quot;, &quot;/&quot;)
    github_client = Github(github.token[&quot;access_token&quot;])
    repo = github_client.get_repo(full_name)
    # ...


@app.route(&quot;/api/like/&lt;repo_name&gt;&quot;)
def like_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;like&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)


@app.route(&quot;/api/read/&lt;repo_name&gt;&quot;)
def read_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;read&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-build-recommender"><a class="header" href="#chapter-2-build-recommender">Chapter 2: Build Recommender</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-management"><a class="header" href="#item-management">Item Management</a></h1>
<p>Items are the main characters of the recommender system. This section will introduce how to manage items in Gorse, including controlling the visibility of items, describing items to the recommender system, etc.</p>
<h2 id="item-properties"><a class="header" href="#item-properties">Item Properties</a></h2>
<p>An item consists of 6 fields:</p>
<pre><code class="language-go">type Item struct {
	ItemId     string
	IsHidden   bool
	Categories []string
	Timestamp  time.Time
	Labels     []string
	Comment    string
}
</code></pre>
<ul>
<li><code>ItemId</code> is the unique identifier of the item and cannot contain a slash &quot;/&quot; because of conflicts with the URL definition of the RESTful API.</li>
<li><code>IsHidden</code> determines whether the item is hidden, after setting true, the item will no longer appear in the recommendation results.</li>
<li><code>Categories</code> is the categories to which the item belongs, the item is recommended under these categories.</li>
<li><code>Timestamp</code> is the timestamp of the item, which is used to determine the freshness of the item.</li>
<li><code>Labels</code> is the item's label information, which is used to describe the item's characteristics to the recommender system.</li>
<li><code>Comment</code> is the item's comment information, which helps to browse items and recommendation results in the dashboard.</li>
</ul>
<h2 id="item-management-1"><a class="header" href="#item-management-1">Item Management</a></h2>
<p>With the help of item fields, items can be managed flexibly.</p>
<h3 id="hide-items"><a class="header" href="#hide-items">Hide Items</a></h3>
<p>In many cases, items in the history are not available for recommendation to other users, e.g.</p>
<ul>
<li>If the item is sold out, it can't be recommended to other users.</li>
<li>If the item is legally risky, it cannot continue to be recommended to other users either.</li>
</ul>
<p>In Gorse, items can be taken down by setting <code>IsHidden</code> to <code>true</code> for the item via the RESTful API. The recommendation algorithm can use the item during training, but the item will no longer be recommended to other users. Setting <code>IsHidden</code> to <code>true</code> takes effect immediately, but setting it to <code>false</code> resumes item recommendations after the <code>refresh_recommend_period</code> has expired.</p>
<h3 id="multi-categories-recommendation"><a class="header" href="#multi-categories-recommendation">Multi-Categories Recommendation</a></h3>
<p>Multi-categories recommendations are common, take YouTube for example, where multiple recommendation categories are provided on the homepage.</p>
<p><img src="img/ch2/youtube-topics.png" alt="" /></p>
<p>Multiple categories can be distinguished by topics such as food, travel, etc., or by forms, e.g. live, short and long videos. Items will definitely appear in the global recommendation stream, and in addition the <code>Categories</code> field determines which recommendation categories the items should appear in. For each recommendation API, there are a global version and category version:</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>GET</td><td>/api/latest</td><td>Get latest items.</td></tr>
<tr><td>GET</td><td>/api/latest/{category}</td><td>Get latest items in specified category.</td></tr>
<tr><td>GET</td><td>/api/popular</td><td>Get popular items.</td></tr>
<tr><td>GET</td><td>/api/popular/{category}</td><td>Get popular items in specified category.</td></tr>
<tr><td>GET</td><td>/api/recommend/{user-id}</td><td>Get recommendation for user.</td></tr>
<tr><td>GET</td><td>/api/recommend/{user-id}/{category}</td><td>Get recommendation for user in specified category.</td></tr>
<tr><td>GET</td><td>/api/item/{item-id}/neighbors</td><td>Get neighbors of a item.</td></tr>
<tr><td>GET</td><td>/api/item/{item-id}/neighbors/{category}</td><td>Get neighbors of a item in specified category.</td></tr>
</tbody></table>
<p>For example, for a live badminton match, you can set its <code>Categories</code> to &quot;Live&quot; and &quot;Sports&quot;. In this way, in addition to the default recommendation stream, the user can find the live stream in the &quot;Live&quot; and &quot;Sports&quot; recommendation categories.</p>
<p><img src="img/ch2/youtube-live.png" alt="" /></p>
<p>Note that multi-column recommendations will consume more Redis cache space.</p>
<h3 id="using-labels-to-describe-items"><a class="header" href="#using-labels-to-describe-items">Using Labels to Describe Items</a></h3>
<p>If only the item ID is available, the recommender system has no knowledge of the item's content, which requires labels to help the recommender system understand the item.</p>
<ul>
<li><strong>User-Generated Label</strong>: Human-supplied labels are generally the most accurate and can be added by editors or users. For example, for a game, editors can add publisher and genres as labels, and users can add topics about the game as labels.</li>
<li><strong>Automatic Label Extraction</strong>: Unfortunately, in many cases, items do not have ready-made labels, so it is necessary to use machine learning to automatically generate labels for items.
<ul>
<li><strong>Image Classification</strong>: The class of image is used as a label, for example, to classify whether the image is a girl, a boy, a cat or a dog.</li>
<li><strong>Object Detection</strong>: Detect the objects contained in the image as labels, e.g. detecting the image as having a girl with a cat.</li>
<li><strong>Keyword Extraction</strong>: Extract the keywords of the text, e.g. an article talks about deep learning based recommender systems, the keywords are deep learning and recommender system.</li>
<li><strong>Text Classification</strong>: Classify the content of a article, for example, to determine whether a tweet is confiding, dating or job hunting.</li>
</ul>
</li>
</ul>
<p>Generating high-quality labels for items is a difficult task, and low-quality labels might harm the accuracy of the recommender system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-collection"><a class="header" href="#feedback-collection">Feedback Collection</a></h1>
<p>In a recommender system, data is the foundation of all recommendation results, and this section will briefly introduce how to collect user data for the Gorse recommender system. The recommender system relies on the feedback between users and items as training data, and the quality of training data determines the quality of recommendations.</p>
<h2 id="users-items-and-feedback-1"><a class="header" href="#users-items-and-feedback-1">Users, Items, and Feedback</a></h2>
<p>The recommender system is complex, but to maximize reusability, Gorse has abstracted the data used in a recommender system as a collection of three entities: users, items, and feedback.</p>
<ul>
<li><strong>User:</strong> A user entity consists of a user ID and labels describing the user. The user labels can be empty, but these labels help to improve the recommendation accuracy of the recommender system.</li>
</ul>
<pre><code class="language-go">type User struct {
    UserId    string
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item entity consists of an item ID, its visibility, its categories, an item timestamp, and labels describing the item. The timestamp and labels can be empty, and similarly based on labels information helps to improve the recommendation accuracy of the recommender system, while the timestamp is used to estimate the freshness of the item. Read <a href="ch02-01-items.html">2.2 Item Management</a> for more information about <code>IsHidden</code> and <code>Categories</code> fields.</li>
</ul>
<pre><code class="language-go">type Item struct {
	ItemId     string
	IsHidden   bool
	Categories []string
	Timestamp  time.Time
	Labels     []string
	Comment    string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback entity consists of user ID, item ID, feedback type, and feedback timestamp, where the triad of user ID, item ID, and feedback type is required to be unique in the database.</li>
</ul>
<p>Feedback represents events that happened between users and items, which can be positive or negative. For example, sharing and liking are the user's positive feedback to an item. If the user does not have further positive feedback after reading, the user's feedback on the item is considered negative. If the user views the item, read feedback will be recorded. Then, if the user gives positive feedback to the item, the read feedback will be overwritten by the positive feedback. Conversely, if the user does not give positive feedback, then the read feedback is considered negative feedback.</p>
<pre><code class="language-go">type Feedback struct {
    FeedbackType string
    UserId       string
    ItemId       string
    Timestamp    time.Time
}
</code></pre>
<p>Gorse's server node provides RESTful APIs for inserting users, items, and feedback, as well as getting a recommendation for users. Please refer to the RESTful API documentation for a detailed description.</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>POST</td><td>/api/item</td><td>Insert item.</td></tr>
<tr><td>POST</td><td>/api/user</td><td>Insert user.</td></tr>
<tr><td>POST</td><td>/api/feedback</td><td>Insert feedback if the feedback not exist.</td></tr>
<tr><td>PUT</td><td>/api/feedback</td><td>Insert feedback, and overwrites existed feedback.</td></tr>
</tbody></table>
<p>The user and item must exist when a feedback is inserted. Gorse server nodes will create new users and new items automatically according to the following configurations:</p>
<pre><code class="language-toml"># Insert new users while inserting feedback. The default value is true.
auto_insert_user = true

# Insert new items while inserting feedback. The default value is true.
auto_insert_item = true
</code></pre>
<p>Auto created users and items have ID only and other fields are all empty.</p>
<h2 id="define-positive-feedback-and-read-feedback"><a class="header" href="#define-positive-feedback-and-read-feedback">Define Positive Feedback and Read Feedback</a></h2>
<p>Before inserting feedback into the Gorse recommender system, it is necessary to define which of the user's behaviors are positive feedback and which are read feedback. Read feedback is relatively easy to define, as it can be recorded as read feedback when a user has seen the recommended item. However, the definition of positive feedback depends more on the specific scenario. For TikTok, users can be considered as positive feedback if they “like” or “share” the current video; for YouTube, users can be considered as positive feedback if they watch the video to a certain proportion of completion, “like“ the video, or &quot;share&quot; the video. To summarize, positive feedback and read feedback are defined by the following rules.</p>
<ul>
<li><strong>Read Feedback:</strong> The user sees the item.</li>
<li><strong>Positive feedback:</strong> The user action that is expected to do by the service provider.</li>
</ul>
<p>For example, if Gabe Newell wants to build a recommender system for Steam based on Gorse, clicking into the game introduction page could be treated as read feedback (the game list page has too little information to determine that the user has read it), and then actions such as adding a wish list and adding a shopping cart are treated as positive feedback. Finally, set them in the configuration file as follows.</p>
<pre><code class="language-toml"># Add to wishlist or cart
positive_feedback_types = [&quot;wish_list&quot;, &quot;cart&quot;]

# Read the game introduction page
read_feedback_types = [&quot;read&quot;]
</code></pre>
<h2 id="insert-positive-feedback"><a class="header" href="#insert-positive-feedback">Insert Positive Feedback</a></h2>
<p>For positive feedback, it can be inserted when the user performs the action, where the timestamp is the current timestamp.</p>
<pre><code class="language-bash">curl -X POST &quot;http://127.0.0.1:8088/api/feedback&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d '[ { &quot;FeedbackType&quot;: &quot;read&quot;, &quot;ItemId&quot;: &quot;10086&quot;, &quot;Timestamp&quot;: &quot;2021-10-24T06:42:20.207Z&quot;, &quot;UserId&quot;: &quot;jack&quot; }]'
</code></pre>
<h2 id="insert-read-feedback"><a class="header" href="#insert-read-feedback">Insert Read Feedback</a></h2>
<p>For read feedback, the timestamp can be used to set the timeout of the recommendation results, in addition to recording the read time.</p>
<h3 id="proactive-insertion"><a class="header" href="#proactive-insertion">Proactive Insertion</a></h3>
<p>Positive feedback can be inserted into the recommender system when the user takes the action, while read feedback requires the application to detect the user's &quot;read&quot; behavior. The methods for displaying recommendations vary by application but can be generally grouped into two categories.</p>
<ul>
<li><strong>Full-screen mode:</strong> The most typical application is TikTok, where the user is considered &quot;read&quot; when the full-screen content is shown to them. That is, the application can write a &quot;read&quot; feedback to the recommender system when the recommended content is shown to the user, and the read content will no longer be shown to the user.</li>
</ul>
<img src="/img/ch2/tiktok.jpg" width="300">
<img src="/img/ch2/youtube.jpg" width="300">
<ul>
<li><strong>List mode:</strong> The most typical application is YouTube, where the user is not considered &quot;read&quot; after looking at multiple videos in the list. When there are more than one videos, the user's attention is not able to browse the whole list. Moreover, if the read content is quickly discarded in the list mode, the recommended content is consumed too fast. Therefore, the best solution is to write a &quot;read&quot; feedback with a future timestamp to the recommender system when the item is presented to the user in the stream, and the &quot;read&quot; feedback will take effect when the time has reached the timestamp, and the read content will no longer be presented to the user.</li>
</ul>
<h3 id="automatic-insertion"><a class="header" href="#automatic-insertion">Automatic Insertion</a></h3>
<p>Proactively inserting read feedback to the recommender system requires the application to be able to accurately capture user browsing behavior. This task is easier for mobile applications but more difficult for web applications. To address this problem, Gorse's API for getting recommendation results provides two parameters: <code>write−back−type</code> and <code>write−back−delay</code>.</p>
<ul>
<li><strong>In full-screen mode:</strong> Get a recommendation and write a &quot;read&quot; feedback, the recommendation will not appear again afterward.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;n=1&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<ul>
<li><strong>In list mode:</strong> Get 10 recommendations and write &quot;read&quot; feedback with timestamps of 10 minutes later. The 10 recommendations will not be discarded until after 10 minutes.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;write-back-delay=10&amp;n=10&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<p>The <code>write−back−type</code> and <code>write−back−delay</code> parameters of the recommendation API provide a convenient way to insert read feedback, but of course, if you want the read feedback to be more accurate, it should be written to the recommender system by the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommendation-strategies"><a class="header" href="#recommendation-strategies">Recommendation Strategies</a></h1>
<p>Gorse recommender system implements different types of recommenders, both non-personalized and personalized. No single recommender is a panacea, and only a combination of them can be used to achieve the best recommendation results.</p>
<p><img src="img/ch2/workflow.png" alt="gitrec" /></p>
<h2 id="recommenders"><a class="header" href="#recommenders">Recommenders</a></h2>
<p>First, this section introduces the various types of recommenders in Gorse, each of which has its pros and cons.</p>
<h3 id="latest-recommender"><a class="header" href="#latest-recommender">Latest Recommender</a></h3>
<p>The latest recommender shows the latest items to users according to timestamps, which allows a new item to be exposed to users in time. However, the downside of the latest recommender is that it does not consider the quality (or popularity) of items. To enable the latest recommender in Gorse, you need to set timestamp information for the items. Without timestamps, Gorse will not generate a list of the latest items.</p>
<pre><code class="language-go">type Item struct {
    ItemId    string
    Timestamp time.Time // The timestamp is required.
    Labels    []string
    Comment   string
}
</code></pre>
<h3 id="popular-recommender"><a class="header" href="#popular-recommender">Popular Recommender</a></h3>
<p>Popular recommender shows the recent popular items to users, most typically Twitter trending. In Gorse, the <code>popular_window</code> in the configuration file corresponds to the window of popular items, the following example is to recommend popular items within one year (a bit too long).</p>
<pre><code class="language-toml">popular_window = 365
</code></pre>
<p>A popular recommender is not suitable to be used alone, otherwise, it would result in new items not being exposed. Many sites display content with a combination of popular and latest recommendations, such as calculating a score based on popularity and freshness and finally sorting by score.</p>
<h3 id="item-based-similarity-recommender"><a class="header" href="#item-based-similarity-recommender">Item-based Similarity Recommender</a></h3>
<p>In some scenarios, users like specific types of items, for example, gamers like to solve puzzles or users of a video platform like to watch dancing girls. Based on the user's history and the similarity between items, an item-based similarity recommender recommends items to users. The critical step of an item-based similarity recommender is to calculate the similarity between items.</p>
<p>Gorse calculates item similarity in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between items.</li>
<li><strong>Related:</strong> Calculates similarity based on user overlap between items.</li>
<li><strong>Automatic:</strong> Prefer to use labels to calculate similarity, if there are no labels then use users to calculate similarity.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for items. There are three types:
#   similar: Neighbors are found by some common labels.
#   related: Neighbors are found by some common users.
#   auto: If an item has labels, neighbors are found by some common labels.
#         If this item has no labels, neighbors are found by some common users.
# The default value is &quot;auto&quot;.
item_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because item-based similarity recommender using <code>related</code> recommends similarly to collaborative filtering recommenders. The advantage of item-based similarity (labels-based) recommender is that it can quickly recommend a new item to users who are interested in such items based on the labels. Of course, this recommender requires accurate labels for the items, and invalid labels are counterproductive.</p>
<h3 id="user-based-similarity-recommender"><a class="header" href="#user-based-similarity-recommender">User-based Similarity Recommender</a></h3>
<p>There are also common preferences among similar users. For example, students majoring in computer science usually buy books about computer science, and elders like to buy health care products.</p>
<p>Gorse calculates the similarity between users in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between users.</li>
<li><strong>Related:</strong> Calculates similarity based on historical item overlap between users.</li>
<li><strong>Automatic:</strong> Prioritizes the use of user labels, if there are no labels then the similarity is calculated using historical items.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for users. There are three types:
#   similar: Neighbors are found by some common labels.
#   related: Neighbors are found by some common liked items.
#   auto: If a user has labels, neighbors are found by some common labels.
#         If this user has no labels, neighbors are found by some common liked items.
# The default value is &quot;auto&quot;.
user_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because user-based Similarity Recommender using <code>related</code> is similar to collaborative filtering recommender. The recommender is friendly to new users. With user labels, recommendations can be generated based on similar users' preferences even if the user does not have any history.</p>
<h3 id="collaborative-filtering-recommender"><a class="header" href="#collaborative-filtering-recommender">Collaborative Filtering Recommender</a></h3>
<p>Recommenders based on similar items and similar users require that the recommended items need to be linked with similar users or historical items of the recommended user, which limits the scope of recommended items searching. The collaborative filtering recommender in Gorse uses matrix factorization to recommend items. The training algorithm maps users and items to embedding vectors in a high-dimensional space, and the user's preference for an item is the dot product of the user embedding vector and the item embedding vector. However, the disadvantage of collaborative filtering recommender is that it cannot utilize the label information of users and items, and it cannot handle new users and new items.</p>
<h3 id="click-through-rate-prediction"><a class="header" href="#click-through-rate-prediction">Click-through Rate Prediction</a></h3>
<p>Is there a recommender that combines the advantages of similarity recommender and collaborative filtering recommender? Then it is the click-through rate, prediction model. The click-through rate prediction model in Gorse is a factorization machine that generates embedding vectors for each user label and item label in addition to embedding vectors for each user and item. Although the factorization machine model is effective, it is not generally used as a recommender for collecting recommended items over all items. Compared with collaborative filtering recommender and similarity recommender, its computational complexity is large. Gorse's click-through prediction model is used to fuse and rank the results of the above recommenders.</p>
<p>The original meaning of &quot;click-through rate prediction&quot; is to predict the probability that users will click on the recommended content or ads, but it should be noted that the click-through rate prediction in Gorse refers more to the probability that users will give positive feedback to the recommended results. For example, suppose we set in Gorse that positive feedback means the user has watched 50% of the video, then the &quot;click-through rate&quot; is the probability that the user has watched more than 50% of the video.</p>
<h2 id="recommendation-strategy"><a class="header" href="#recommendation-strategy">Recommendation Strategy</a></h2>
<p>Individual recommenders cannot perform the recommendation task well, and multiple recommenders need to be combined. Gorse provides a workflow for generating recommendation results, under which we can draft recommendation strategies that are suitable for specific scenarios. The recommendation process consists of two main components: offline recommendation and online recommendation. The offline recommendation collects recommendations for each user from the full set of items and caches them in Redis. The online recommendation pulls the cached recommendation results, then removes the read content from the recommendation results, and if the cached recommendation results are exhausted, then the recommendation content is generated in real-time using the fallback recommenders.</p>
<h3 id="offline-strategy"><a class="header" href="#offline-strategy">Offline Strategy</a></h3>
<p>Offline recommendation consists of three phases.</p>
<ul>
<li><strong>Matching:</strong> Use different full-set recommenders to collect recommended items from all items. There are five types of full-set recommenders: popular recommender, latest recommender, item-based similarity recommender, user-based similarity recommender, and collaborative filtering recommender, which can be set on or off in the configuration file.</li>
<li><strong>Ranking:</strong> Use the factorization machine model to rank the items collected by the matching phase, currently you can also turn off the click-through rate prediction in the configuration and use random merge.</li>
<li><strong>Exploration:</strong> Recommend content based on user history can be a good idea for users, but it also limits the possibility of users seeing more diverse content. It is also a kind of &quot;exploration and exploitation&quot; problem, where exploitation refers to recommending content based on users' historical behavior, while exploration refers to exposing users to more content beyond their awareness. One of the easiest ways to expose users to content beyond the information cocoon is to insert random items into the recommendation list, and Gorse can be configured to randomly insert the newest or recent popular items into the recommendation list, with their proportion set in the configuration file.</li>
</ul>
<pre><code class="language-toml"># Enable latest recommendation during offline recommendation. The default values is false.
enable_latest_recommend = true

# Enable popular recommendation during offline recommendation. The default values is false.
enable_popular_recommend = false

# Enable user-based similarity recommendation during offline recommendation. The default values is false.
enable_user_based_recommend = true

# Enable item-based similarity recommendation during offline recommendation. The default values is false.
enable_item_based_recommend = false

# Enable collaborative filtering recommendation during offline recommendation. The default values is true.
enable_collaborative_recommend = true

# Enable click-though rate prediction during offline recommendation. Otherwise, results from multi-way recommendation
# would be merged randomly. The default values is true.
enable_click_through_prediction = true

# The explore recommendation method is used to inject popular items or latest items into recommended result:
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# The default values is { popular = 0.0, latest = 0.0 }.
explore_recommend = { popular = 0.1, latest = 0.2 }
</code></pre>
<p>Perhaps the introduction of various recommenders is not intuitive enough, you can preview the recommendation results in the dashboard. The popular items and the latest items can be seen on the landing page of the dashboard.</p>
<p><img src="img/ch2/latest-and-popular.png" alt="latest-and-popular" /></p>
<p>The results of offline recommendation, item-based similarity recommendation, user-based similarity recommendation, and collaborative filtering recommendation can be viewed on the user page by clicking <em>Insight</em>:</p>
<ul>
<li>Click <em>Users</em> in the navigation bar</li>
<li>Click <em>Insight</em> in the user row</li>
</ul>
<p>You can choose to show offline recommendation results, similarity item recommendation, similar user recommendation, and collaborative filtering recommendation results from the drop-down menu on the right side</p>
<p><img src="img/ch2/users.png" alt="users" /></p>
<p><img src="img/ch2/user-insight.png" alt="user-insight" /></p>
<p>Since Gorse does not yet offer A/B testing, the preview is needed to sensitively draft a recommendation strategy.</p>
<h3 id="online-strategy"><a class="header" href="#online-strategy">Online Strategy</a></h3>
<p>Online recommendations have three tasks.</p>
<ul>
<li><strong>Remove reads:</strong> The read items in the recommendation result cache need to be removed.</li>
<li><strong>Fallback:</strong> There might be a situation where the cached recommendation results are drained out but new offline recommendations haven't been generated, then the fallback recommenders are needed to generate the recommendation content in real-time. The fallback recommenders can be configured in the configuration file with priority from head to tail, and if the front recommender is no longer able to generate a recommendation, then continue to try the backward recommender.</li>
</ul>
<pre><code class="language-toml"># The fallback recommendation method for cold-start users:
#   item_based: Recommend similar items to cold-start users.
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# The default values is [&quot;latest&quot;].
fallback_recommend = [&quot;item_based&quot;, &quot;latest&quot;]
</code></pre>
<p>The fallback version of item-based similarity recommendation limit the number of feedbacks used. Only most recent <code>num_feedback_fallback_item_based</code> items are used which is set by configuration.</p>
<pre><code class="language-toml"># The number of feedback used in fallback item-based similar recommendation. The default values is 10.
num_feedback_fallback_item_based = 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-vs-precision"><a class="header" href="#performance-vs-precision">Performance vs Precision</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gorse-dashboard"><a class="header" href="#gorse-dashboard">Gorse Dashboard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-monitoring"><a class="header" href="#chapter-3-monitoring">Chapter 3: Monitoring</a></h1>
<p>For an online system in production, &quot;observability&quot; is important. Real-time monitoring of an online system can identify flaws or performance issues before they affect users on a large scale. This chapter will introduce how to monitor the Gorse recommender system for logs and metrics, with the logs capturing abnormal events and the metrics monitoring observing the performance of the system. This chapter will only introduce some key configurations, for a complete configuration sample please refer to the official demo project <a href="https://github.com/zhenghaoz/gitrec">GitRec</a>.</p>
<p>The overview architecture of monitoring infrastructure is as follows:</p>
<ul>
<li>Gorse nodes write logs to log files.</li>
<li><strong>Promtail</strong> reads logs from the file and pushes them to <strong>Loki</strong>.</li>
<li><strong>Prometheus</strong> scrapes metrics from Gorse nodes.</li>
<li><strong>Grafana</strong> visualizes logs from <strong>Loki</strong> and metrics from <strong>Prometheus</strong> in dashboards.</li>
</ul>
<img src="img/ch3/monitoring.png" width="600">
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-monitoring"><a class="header" href="#log-monitoring">Log Monitoring</a></h1>
<p>The mainstream log monitoring solutions are ELK and Loki. Loki is chosen in this section because it is more lightweight compared to ELK. The log collection and monitoring process is as follows.</p>
<ul>
<li>Gorse nodes write the logs to a file.</li>
<li>Promtail reads the logs from the file and pushes them to Loki.</li>
<li>Grafana reads the logs from Loki for visualization.</li>
</ul>
<p>First, you need to set each node to write logs to a file in <code>docker-compose.yml</code>, as well as add Promtail, Loki, and Grafana.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  worker:
    image: zhenghaoz/gorse-worker
    restart: unless-stopped
    ports:
      - 8089:8089
    command: &gt;
      --master-host master --master-port 8086 --http-host 0.0.0.0 --http-port 8089
      --log-path /var/log/gorse/worker.log --cache-path /var/lib/gorse/worker_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - worker_data:/var/lib/gorse
    depends_on:
      - master

  server:
    image: zhenghaoz/gorse-server
    restart: unless-stopped
    ports:
      - 8087:8087
    command: &gt;
      --master-host master --master-port 8086 --http-host 0.0.0.0 --http-port 8087
      --log-path /var/log/gorse/server.log --cache-path /var/lib/gorse/server_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - server_data:/var/lib/gorse
    depends_on:
      - master

  master:
    image: zhenghaoz/gorse-master
    restart: unless-stopped
    ports:
      - 8086:8086
      - 8088:8088
    command: -c /etc/gorse/config.toml --log-path /var/log/gorse/master.log --cache-path /var/lib/gorse/master_cache.data
    volumes:
      - ./etc/gorse/config.toml:/etc/gorse/config.toml
      - gorse_log:/var/log/gorse
      - master_data:/var/lib/gorse
    depends_on:
      - redis
      - mysql

  grafana:
    image: grafana/grafana
    restart: unless-stopped
    ports:
      - 3000:3000
    volumes:
      - grafana-storage:/var/lib/grafana

  loki:
    image: grafana/loki
    restart: unless-stopped
    command: -config.file=/etc/loki/local-config.yaml
    ports:
      - 3100:3100
    volumes:
      - ./etc/loki/local-config.yaml:/etc/loki/local-config.yaml

  promtail:
    image: grafana/promtail
    restart: unless-stopped
    command: -config.file=/etc/promtail/config.yml
    ports:
      - 9080:9080
    volumes:
      - gorse_log:/var/log/gorse
      - ./etc/promtail/config.yml:/etc/promtail/config.yml

# ...

volumes:
  mysql_data:
  worker_data:
  server_data:
  master_data:
  gorse_log:
  grafana-storage:
</code></pre>
<p>Loki's configuration file <code>local-config.yaml</code> is as follows.</p>
<pre><code class="language-yaml">auth_enabled: false

server:
  http_listen_port: 3100

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
    final_sleep: 0s
  chunk_idle_period: 5m
  chunk_retain_period: 30s

schema_config:
  configs:
    - from: 2020-05-15
      store: boltdb
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 168h

storage_config:
  boltdb:
    directory: /tmp/loki/index

  filesystem:
    directory: /tmp/loki/chunks

limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h
</code></pre>
<p>The configuration file for Promtail is as follows.</p>
<pre><code class="language-yaml">server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /var/log/positions.yaml # This location needs to be writeable by Promtail.

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: system
    static_configs:
    - targets:
        - localhost
      labels:
        job: master
        __path__: /var/log/gorse/master.log
    - targets:
        - localhost
      labels:
        job: worker
        __path__: /var/log/gorse/worker.log
    - targets:
        - localhost
      labels:
        job: server
        __path__: /var/log/gorse/server.log
    pipeline_stages:
    - json:
        expressions:
          level: level
    - labels:
        level:
</code></pre>
<p>After deploying <code>docker-compose.yml</code>, login to Grafana and add Loki as a data source:</p>
<img src="img/ch3/loki.png" width="500">
<p>Finally, import the logs dashboard provided in the demo project GitRec to monitor warnings, errors, and fatal logs in the recommender system in real-time.</p>
<img src="img/ch3/dashboard-logs-json.png" width="500">
<p>The logs dashboard filters warning, error, and fatal logs.</p>
<ul>
<li><strong>Warning:</strong> Events affect the outcome of the recommender system, but the system has a strategy to deal with them.</li>
<li><strong>Error:</strong> Events affect the function of the system, but the system is still able to continue.</li>
<li><strong>Fatal:</strong> Events prevent the system from continuing to run.</li>
</ul>
<p>Log entries such as database temporarily connection lost, network temporarily timeout, etc. are expected. If an error log is generated that is not expected, welcome to paste it on <a href="https://github.com/zhenghaoz/gorse/issues">GitHub Issues</a>.</p>
<p><img src="/img/ch3/dashboard-logs-preview.jpeg" alt="dashboard-logs-preview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-monitoring"><a class="header" href="#metrics-monitoring">Metrics Monitoring</a></h1>
<p>Gorse nodes export Prometheus metrics, and Prometheus can scrape real-time metrics via HTTP from each node. The default HTTP port for worker nodes is <code>8089</code>, the default HTTP port for server nodes is <code>8087</code>, and the default HTTP port for master nodes is <code>8088</code>. The HTTP port for worker and server nodes can be set via the command line option <code>--http-port</code>.</p>
<p>The Prometheus configuration file for scraping Gorse metrics is as follows.</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name:       'gorse'
    scrape_interval: 10s
    static_configs:
      - targets: ['worker:8089', 'server:8087', 'master:8088']
</code></pre>
<p><code>scrape_interval</code> is the scraping frequency and <code>targets</code> is the address to scrape the metrics. Since the above configuration file is used for Docker Compose deployments, the hostname is used instead of the IP address. Next, add an instance of Prometheus to <code>docker-compose.yml</code>, mount the above configuration file to the default configuration file path <code>/etc/prometheus/prometheus.yml</code>.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:

  prometheus:
    image: prom/prometheus
    restart: unless-stopped
    ports:
      - 9090:9090
    volumes:
      - ./etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
</code></pre>
<p>After Prometheus started, add Prometheus as a data source in Grafana.</p>
<img src="img/ch3/prometheus.png" width="500">
<p>Finally, import dashboards provided in the demo project GitRec to monitor the count and latency of each service call on the database, cache, worker node, server node, and master node in real-time.</p>
<img src="img/ch3/dashboard-json.png" width="500">
<p>The left side of the dashboard shows the count of calls per ten minutes, while the right side shows the call latency within 99%.</p>
<p><img src="img/ch3/dashboard-cache.png" alt="dashboard-cache" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-developers-guide"><a class="header" href="#chapter-4-developers-guide">Chapter 4: Developer's Guide</a></h1>
<p>This chapter will show how to work on Gorse source code.</p>
<h2 id="setup-develop-environment"><a class="header" href="#setup-develop-environment">Setup Develop Environment</a></h2>
<p>These following installations are required:</p>
<ul>
<li><strong>Go</strong> (&gt;= 1.17): Since Go features from 1.17 are used in Gorse, the version of the compiler must be greater than 1.17. GoLand or Visual Studio Code is highly recommended as the IDE to develop Gorse.</li>
<li><strong>Docker Compose</strong>: Multiple databases are required for unit tests. It's convenient to manage databases on Docker Compose. </li>
</ul>
<pre><code class="language-bash">cd misc/database_test
docker-compose up -d
</code></pre>
<h2 id="run-unit-tests"><a class="header" href="#run-unit-tests">Run Unit Tests</a></h2>
<p>Most logics in Gorse are covered by unit tests. Run unit tests by the following command:</p>
<pre><code class="language-bash">go test -v ./...
</code></pre>
<p>The default database URLs are directed to these databases in <code>misc/database_test/docker-compose.yml</code>. Test databases could be overrode by setting following environment variables:</p>
<table><thead><tr><th>Environment Value</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>MYSQL_URI</code></td><td><code>mysql://root:password@tcp(127.0.0.1:3306)/</code></td></tr>
<tr><td><code>POSTGRES_URI</code></td><td><code>postgres://gorse:gorse_pass@127.0.0.1/</code></td></tr>
<tr><td><code>MONGO_URI</code></td><td><code>mongodb://root:password@127.0.0.1:27017/</code></td></tr>
<tr><td><code>CLICKHOUSE_URI</code></td><td><code>clickhouse://127.0.0.1:8123/</code></td></tr>
<tr><td><code>REDIS_URI</code></td><td><code>redis://127.0.0.1:6379/</code></td></tr>
</tbody></table>
<p>For example, use TiDB as a test database by:</p>
<pre><code class="language-bash">MYSQL_URI=mysql://root:password@tcp(127.0.0.1:4000)/ go test -v ./...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>These frequent asked questions are collected from issues, emails and chats. Feel free to ask more questions via <a href="https://github.com/zhenghaoz/gorse/issues">issue</a>, <a href="support@gorse.io">email</a>, <a href="https://discord.com/channels/830635934210588743/">Discord</a> (for English) or <a href="https://qm.qq.com/cgi-bin/qm/qr?k=lOERnxfAM2U2rj4C9Htv9T68SLIXg6uk&amp;jump_from=webapi">QQ</a> (for Chinese).</p>
<h3 id="1-how-to-address-the-cold-start-problem"><a class="header" href="#1-how-to-address-the-cold-start-problem">1. How to address the cold-start problem?</a></h3>
<p>Use <code>explore_recommend</code> to inject the latest items or recently popular items into a recommendation. Also, item labels are helpful to rank new items in a recommendation. For example:</p>
<pre><code class="language-toml">explore_recommend = { popular = 0.1, latest = 0.2 }
</code></pre>
<p>It means latest items are inserted into recommended items list in a probability of 0.1 and recently popular items are inserted into recommended items list in a probability of 0.2.</p>
<h3 id="2-how-to-keep-track-of-items-recommended-to-each-user"><a class="header" href="#2-how-to-keep-track-of-items-recommended-to-each-user">2. How to keep track of items recommended to each user?</a></h3>
<p>There are two options:</p>
<ol>
<li>Insert read-type feedback to Gorse when an item is shown to a user. This is the way the official demo <a href="https://github.com/zhenghaoz/gitrec">zhenghaoz/gitrec</a> tracks user-seen recommendations.</li>
<li>Use <code>write-back-type</code> and <code>write-back-delay</code> parameter to write back recommendations as read feedbacks to Gorse, eg:</li>
</ol>
<pre><code class="language-bash">curl -i -H &quot;Accept: application/json&quot; \
    -X GET http://127.0.0.1:8088//api/recommend/0?write-back-type=read&amp;write-back-delay=10
</code></pre>
<p>The 1st option is more accurate since it is done by the front end but the 2nd option is more convenient. Read <a href="ch02-03-strategy.html">2.3 Recommendation Strategies</a> for detailed information.</p>
<h3 id="3-what-does-no-feedback-found-mean"><a class="header" href="#3-what-does-no-feedback-found-mean">3. What does &quot;no feedback found&quot; mean?</a></h3>
<p>If &quot;collaborative filtering&quot; tasks report no feedback found. It means there is no positive feedback in the database. The definition of positive feedback types and read feedback type is in the configuration file:</p>
<pre><code class="language-toml"># The feedback types for positive events.
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# The feedback types for read events.
read_feedback_types = [&quot;read&quot;]
</code></pre>
<p>If &quot;click-through rate prediction&quot; tasks report no feedback found. It means there is no negative feedback in the database. The negative feedback are these read feedback without positive feedback.</p>
<p>If you don't have any feedback, don't worry. There are fallback recommenders to handle cold-start problem.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
