<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gorse Document</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-deploy.html"><strong aria-hidden="true">1.1.</strong> Deploy</a></li><li class="chapter-item expanded "><a href="ch01-02-restful-api.html"><strong aria-hidden="true">1.2.</strong> RESTful APIs</a></li><li class="chapter-item expanded "><a href="ch01-03-config.html"><strong aria-hidden="true">1.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="ch01-04-demo.html"><strong aria-hidden="true">1.4.</strong> GitRec, The Live Demo</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2: Build Recommender</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-items.html"><strong aria-hidden="true">2.1.</strong> Item Management</a></li><li class="chapter-item expanded "><a href="ch02-02-feedback.html"><strong aria-hidden="true">2.2.</strong> Feedback Collection</a></li><li class="chapter-item expanded "><a href="ch02-03-strategy.html"><strong aria-hidden="true">2.3.</strong> Recommendation Strategies</a></li><li class="chapter-item expanded "><a href="ch02-04-performance.html"><strong aria-hidden="true">2.4.</strong> Performance vs Precision</a></li><li class="chapter-item expanded "><a href="ch02-05-dashboard.html"><strong aria-hidden="true">2.5.</strong> Gorse Dashboard</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: Monitoring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-logging.html"><strong aria-hidden="true">3.1.</strong> Log Monitoring</a></li><li class="chapter-item expanded "><a href="ch03-02-metrics.html"><strong aria-hidden="true">3.2.</strong> Metrics Monitoring</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Chapter 4: Developer's Guide</a></li><li class="chapter-item expanded affix "><a href="faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gorse Document</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Gorse is an open-source recommendation system written in Go. Gorse aims to be a universal open-source recommender system that can be easily introduced into a wide variety of online services. By importing items, users, and interaction data into Gorse, the system will automatically train models to generate recommendations for each user. Project features are as follows.</p>
<ul>
<li><strong>Multi-source Recommendation:</strong> For a user, recommended items are collected from different ways (popular, latest, user-based, item-based, and collaborative filtering) and ranked by click-through rate prediction.</li>
<li><strong>AutoML:</strong> Choose the best recommendation model and strategy automatically by model searching in the background.</li>
<li><strong>Distributed Recommendation:</strong> Single node training, distributed prediction, and ability to achieve horizontal scaling in the recommendation stage.</li>
<li><strong>RESTful API:</strong> Provide RESTful APIs for data CRUD and recommendation requests.</li>
<li><strong>Dashboard:</strong> Provide dashboard for data import and export, monitoring, and cluster status checking.</li>
</ul>
<p>Gorse is a single node training and distributed prediction recommender system. Gorse stores data in MySQL, MongoDB, PostgresSQL, or ClickHouse, with intermediate data cached in Redis.</p>
<ol>
<li>The cluster consists of a master node, multiple worker nodes, and server nodes.</li>
<li>The master node is responsible for model training, non-personalized item recommendation, configuration management, and membership management.</li>
<li>The server node is responsible for exposing the RESTful APIs and online real-time recommendations.</li>
<li>Worker nodes are responsible for offline recommendations for each user.</li>
</ol>
<p>In addition, the administrator can perform system monitoring, data import and export, and system status checking via the dashboard on the master node.</p>
<center><img width=480 src="img/architecture.png"/></center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-quick-start"><a class="header" href="#chapter-1-quick-start">Chapter 1: Quick Start</a></h1>
<p>This guide walks you through the quickest way to setup a recommender system for GitHub repositories. Make sure you have installed following softwares at the beginning: </p>
<ul>
<li><a href="https://docs.docker.com/get-docker/">Docker</a>, nodes will run in containers.</li>
<li><a href="https://docs.docker.com/compose/install/">Docker Compose</a>, nodes will be orchestrated by Docker Compose.</li>
</ul>
<h2 id="setup-gorse"><a class="header" href="#setup-gorse">Setup Gorse</a></h2>
<p>There is an example <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/docker-compose.yml">docker-compose.yml</a> consists of a master node, a server node and a worker node, a Redis instance, and a MySQL instance.</p>
<ul>
<li>Download <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/docker-compose.yml">docker-compose.yml</a> and the config file <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">config.toml</a>. The config file is explained in <a href="ch01-03-config.html">Section 1.3 Configuration</a>.</li>
</ul>
<pre><code class="language-bash"># Create a new directory
mkdir gorse
cd gorse

# Download docker-compose.yml and config.tom
wget https://raw.githubusercontent.com/zhenghaoz/gorse/master/docker/docker-compose.yml
wget https://raw.githubusercontent.com/zhenghaoz/gorse/master/docker/config.toml
</code></pre>
<ul>
<li>Setup the Gorse cluster using Docker Compose.</li>
</ul>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<details>
<summary>Expected outputs:</summary>
<pre><code>Creating network &quot;gorse_default&quot; with the default driver
Creating gorse_worker_1 ... done
Creating gorse_master_1 ... done
Creating gorse_mysql_1  ... done
Creating gorse_server_1 ... done
Creating gorse_redis_1  ... done
</code></pre>
</details>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import to the MySQL instance. This dataset consists of GitHub users, GitHub repositories and star records.</li>
</ul>
<pre><code class="language-bash"># Download sample data.
wget https://cdn.gorse.io/example/github.sql

# Import sample data.
mysql -h 127.0.0.1 -u gorse -pgorse_pass gorse &lt; github.sql
</code></pre>
<ul>
<li>Restart the master node to apply imported data.</li>
</ul>
<pre><code class="language-bash">docker-compose restart
</code></pre>
<details>
<summary>Expected outputs:</summary>
<pre><code>Restarting gorse_redis_1  ... done
Restarting gorse_mysql_1  ... done
Restarting gorse_master_1 ... done
Restarting gorse_server_1 ... done
Restarting gorse_worker_1 ... done
</code></pre>
</details>
<h2 id="get-recommendation"><a class="header" href="#get-recommendation">Get Recommendation</a></h2>
<p>Gorse generate recommendations for users after feedbacks from users are inserted.</p>
<ul>
<li>Open <a href="http://127.0.0.1:8088">http://127.0.0.1:8088</a> in browser and log in with default user name <code>admin</code> and password <code>password</code>. The dashboard summarizes all status and data in Gorse. Read <a href="ch02-05-dashboard.html">Section 2.5 Gorse Dashboard</a> for more information.</li>
</ul>
<p><img src="img/ch3/gorse-dashboard-overview.png" alt="" /></p>
<ul>
<li>Wait for all tasks <em>except &quot;Searching collaborative filtering model&quot; and &quot;Searching click-through prediction model&quot;</em> completed.</li>
</ul>
<p><img src="/img/ch3/gorse-dashboard-tasks.png" alt="" /></p>
<ul>
<li>Suppose Bob is a frontend developers who starred several frontend repositories in GitHub. We insert his star feedback to Gorse via the RESTful API. <a href="ch01-02-restful-api.html">Section 1.2</a> lists RESTful APIs available in Gorse.</li>
</ul>
<pre><code class="language-bash">read -d '' JSON &lt;&lt; EOF
[
    { \&quot;FeedbackType\&quot;: \&quot;star\&quot;, \&quot;UserId\&quot;: \&quot;bob\&quot;, \&quot;ItemId\&quot;: \&quot;vuejs:vue\&quot;, \&quot;Timestamp\&quot;: \&quot;2022-02-24\&quot; },
    { \&quot;FeedbackType\&quot;: \&quot;star\&quot;, \&quot;UserId\&quot;: \&quot;bob\&quot;, \&quot;ItemId\&quot;: \&quot;d3:d3\&quot;, \&quot;Timestamp\&quot;: \&quot;2022-02-25\&quot; },
    { \&quot;FeedbackType\&quot;: \&quot;star\&quot;, \&quot;UserId\&quot;: \&quot;bob\&quot;, \&quot;ItemId\&quot;: \&quot;dogfalo:materialize\&quot;, \&quot;Timestamp\&quot;: \&quot;2022-02-26\&quot; },
    { \&quot;FeedbackType\&quot;: \&quot;star\&quot;, \&quot;UserId\&quot;: \&quot;bob\&quot;, \&quot;ItemId\&quot;: \&quot;mozilla:pdf.js\&quot;, \&quot;Timestamp\&quot;: \&quot;2022-02-27\&quot; },
    { \&quot;FeedbackType\&quot;: \&quot;star\&quot;, \&quot;UserId\&quot;: \&quot;bob\&quot;, \&quot;ItemId\&quot;: \&quot;moment:moment\&quot;, \&quot;Timestamp\&quot;: \&quot;2022-02-28\&quot; }
]
EOF

curl -X POST http://127.0.0.1:8087/api/feedback \
   -H 'Content-Type: application/json' \
   -d &quot;$JSON&quot;
</code></pre>
<details>
<summary>Expected outputs:</summary>
<pre><code class="language-json">{
 &quot;RowAffected&quot;: 5
}
</code></pre>
</details>
<ul>
<li>Fetch 10 recommended items from Gorse. We can found frontend related repositories are recommended for Bob.</li>
</ul>
<pre><code class="language-bash">curl http://127.0.0.1:8087/api/recommend/bob?n=10
</code></pre>
<p>Expected outputs:</p>
<pre><code class="language-json">[
 &quot;mbostock:d3&quot;,
 &quot;nt1m:material-framework&quot;,
 &quot;mdbootstrap:vue-bootstrap-with-material-design&quot;,
 &quot;justice47:f2-vue&quot;,
 &quot;10clouds:cyclejs-cookie&quot;,
 &quot;academicpages:academicpages.github.io&quot;,
 &quot;accenture:alexia&quot;,
 &quot;addyosmani:tmi&quot;,
 &quot;1wheel:d3-starterkit&quot;,
 &quot;acdlite:redux-promise&quot;
]
</code></pre>
<p>A complete example to build a recommender system is discussed in <a href="ch01-04-demo.html">Section 1.5 GitRec, The Live Demo</a>, which is useful to learn Gorse.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy"><a class="header" href="#deploy">Deploy</a></h1>
<p>The best practice to manage Gorse nodes is using orchestration tools such as Docker Compose, etc. There are Docker images of the master node, the server node, and the worker node.</p>
<table><thead><tr><th>Docker Image</th><th>Version</th><th>Size</th><th>Pulls</th></tr></thead><tbody>
<tr><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-master">zhenghaoz/gorse-master</a></td><td><img src="https://img.shields.io/docker/v/zhenghaoz/gorse-master?sort=semver" alt="Docker Image Version (latest semver)" /></td><td><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-master?sort=semver" alt="gorse-master" /></td><td><img src="https://img.shields.io/docker/pulls/zhenghaoz/gorse-master" alt="Docker Pulls" /></td></tr>
<tr><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-server">zhenghaoz/gorse-server</a></td><td><img src="https://img.shields.io/docker/v/zhenghaoz/gorse-server?sort=semver" alt="Docker Image Version (latest semver)" /></td><td><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-server?sort=semver" alt="gorse-server" /></td><td><img src="https://img.shields.io/docker/pulls/zhenghaoz/gorse-server" alt="Docker Pulls" /></td></tr>
<tr><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-worker">zhenghaoz/gorse-worker</a></td><td><img src="https://img.shields.io/docker/v/zhenghaoz/gorse-worker?sort=semver" alt="Docker Image Version (latest semver)" /></td><td><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-worker?sort=semver" alt="gorse-worker" /></td><td><img src="https://img.shields.io/docker/pulls/zhenghaoz/gorse-worker" alt="Docker Pulls" /></td></tr>
</tbody></table>
<h2 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h2>
<p>Gorse depends on following software:</p>
<ul>
<li><em>Redis</em> is used to store caches.</li>
<li>One of <em>MySQL/PostgresSQL/ClickHouse/MongoDB</em> is used to store data.</li>
</ul>
<p>The minimal versions of dependent software are as follows:</p>
<table><thead><tr><th>Software</th><th>Minimal Version</th><th>Compatible Product</th></tr></thead><tbody>
<tr><td>Redis</td><td>5.0</td><td></td></tr>
<tr><td>MySQL</td><td>5.7</td><td>MariaDB &gt;= 10.2</td></tr>
<tr><td>PostgresSQL</td><td>10.0</td><td></td></tr>
<tr><td>ClickHouse</td><td>21.10</td><td></td></tr>
<tr><td>MongoDB</td><td>4.0</td><td></td></tr>
</tbody></table>
<h2 id="command-line-flags"><a class="header" href="#command-line-flags">Command Line Flags</a></h2>
<p>Command line flags are useful when deploy the Gorse cluster.</p>
<ul>
<li>Flags of the master node.</li>
</ul>
<table><thead><tr><th>Flag</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-v,--version</code></td><td></td><td>print Gorse version</td></tr>
<tr><td><code>-c,--config</code></td><td></td><td>configuration file path</td></tr>
<tr><td><code>--debug</code></td><td></td><td>use debug log mode</td></tr>
<tr><td><code>--log-path</code></td><td></td><td>path of log file</td></tr>
<tr><td><code>--cache-path</code></td><td><code>worker_cache.data</code></td><td>path of cache file</td></tr>
</tbody></table>
<ul>
<li>Flags of the server node.</li>
</ul>
<table><thead><tr><th>Flag</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-v,--version</code></td><td></td><td>print Gorse version</td></tr>
<tr><td><code>--master-host</code></td><td><code>127.0.0.1</code></td><td>host of master node</td></tr>
<tr><td><code>--master-port</code></td><td><code>8086</code></td><td>port of master port</td></tr>
<tr><td><code>--http-host</code></td><td><code>127.0.0.1</code></td><td>host for RESTful APIs and<br>Prometheus metrics export</td></tr>
<tr><td><code>--http-port</code></td><td><code>8087</code></td><td>port for RESTful APIs and<br>Prometheus metrics export</td></tr>
<tr><td><code>--debug</code></td><td></td><td>use debug log mode</td></tr>
<tr><td><code>--log-path</code></td><td></td><td>path of log file</td></tr>
<tr><td><code>--cache-path</code></td><td><code>worker_cache.data</code></td><td>path of cache file</td></tr>
</tbody></table>
<ul>
<li>Flags of the worker node.</li>
</ul>
<table><thead><tr><th>Flag</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-v,--version</code></td><td></td><td>print Gorse version</td></tr>
<tr><td><code>--master-host</code></td><td><code>127.0.0.1</code></td><td>host of master node</td></tr>
<tr><td><code>--master-port</code></td><td><code>8086</code></td><td>port of master port</td></tr>
<tr><td><code>--http-host</code></td><td><code>127.0.0.1</code></td><td>host for Prometheus metrics export</td></tr>
<tr><td><code>--http-port</code></td><td><code>8089</code></td><td>port for Prometheus metrics export</td></tr>
<tr><td><code>--debug</code></td><td></td><td>use debug log mode</td></tr>
<tr><td><code>-j,--jobs</code></td><td><code>1</code></td><td>number of working jobs</td></tr>
<tr><td><code>--log-path</code></td><td></td><td>path of log file</td></tr>
<tr><td><code>--cache-path</code></td><td><code>worker_cache.data</code></td><td>path of cache file</td></tr>
</tbody></table>
<h2 id="deploy-gorse-in-docker-compose"><a class="header" href="#deploy-gorse-in-docker-compose">Deploy Gorse in Docker Compose</a></h2>
<p>docker-compose.yaml for a minimal Gorse cluster is as follows:</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  redis:
    image: redis
    restart: unless-stopped
    ports:
      - 6379:6379

  mysql:
    image: mysql/mysql-server
    restart: unless-stopped
    ports:
      - 3306:3306
    environment:
      MYSQL_ROOT_PASSWORD: root_pass
      MYSQL_DATABASE: gorse
      MYSQL_USER: gorse
      MYSQL_PASSWORD: gorse_pass
    volumes:
      - mysql_data:/var/lib/mysql

  worker:
    image: zhenghaoz/gorse-worker
    restart: unless-stopped
    ports:
      - 8089:8089
    command: &gt;
      --master-host master 
      --master-port 8086 
      --http-host 0.0.0.0 
      --http-port 8089
      --log-path /var/log/gorse/worker.log 
      --cache-path /var/lib/gorse/worker_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - worker_data:/var/lib/gorse
    depends_on:
      - master

  server:
    image: zhenghaoz/gorse-server
    restart: unless-stopped
    ports:
      - 8087:8087
    command: &gt;
      --master-host master 
      --master-port 8086 
      --http-host 0.0.0.0 
      --http-port 8087
      --log-path /var/log/gorse/server.log 
      --cache-path /var/lib/gorse/server_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - server_data:/var/lib/gorse
    depends_on:
      - master

  master:
    image: zhenghaoz/gorse-master
    restart: unless-stopped
    ports:
      - 8086:8086
      - 8088:8088
    command: &gt;
      -c /etc/gorse/config.toml 
      --log-path /var/log/gorse/master.log 
      --cache-path /var/lib/gorse/master_cache.data
    volumes:
      - ./config.toml:/etc/gorse/config.toml
      - gorse_log:/var/log/gorse
      - master_data:/var/lib/gorse
    depends_on:
      - redis
      - mysql

volumes:
  mysql_data:
  worker_data:
  server_data:
  master_data:
  gorse_log:
</code></pre>
<ul>
<li>The master node loads the config file from <code>/etc/gorse/config.toml</code> (mounted to <code>./config.toml</code>), writes the log file to <code>/var/log/gorse/master.log</code> (mounted in &quot;gorse_log&quot; volume) and writes the cache file to <code>/var/lib/gorse/master_cache.data</code> (mounted in &quot;master_data&quot; volume). The addresses of Redis and MySQL are specified in configuration file <a href="ch01-03-config.html#database">(1.3)</a> or by environment variables <a href="ch01-03-config.html#environment-variables">(1.3)</a>.</li>
</ul>
<pre><code class="language-toml"># The database for caching, support Redis only:
#   redis://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;db_number&gt;
cache_store = &quot;redis://redis:6379&quot;

# The database for persist data, support MySQL, Postgres, ClickHouse and MongoDB:
#   mysql://[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]
#   postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full
#   clickhouse://user:password@host[:port]/database?param1=value1&amp;...&amp;paramN=valueN
#   mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[defaultauthdb][?options]]
data_store = &quot;mysql://gorse:gorse_pass@tcp(mysql:3306)/gorse?parseTime=true&quot;
</code></pre>
<ul>
<li>
<p>The server node synchronizes with the master node at port <code>8086</code>, writes the log file to <code>/var/log/gorse/server.log</code> (mounted in &quot;gorse_log&quot; volume) and writes the cache file to <code>/var/lib/gorse/server_cache.data</code> (mounted in &quot;server_data&quot; volume). The entrypoint for RESTful APIs and Prometheus metrics export is <code>worker:8087</code>.</p>
</li>
<li>
<p>The worker node synchronizes with the master node at port <code>8086</code>, writes the log file to <code>/var/log/gorse/worker.log</code> (mounted in &quot;gorse_log&quot; volume) and writes the cache file to <code>/var/lib/gorse/worker_cache.data</code> (mounted in &quot;worker_data&quot; volume). The entrypoint for Prometheus metrics export is <code>worker:8089</code>.</p>
</li>
</ul>
<h2 id="deploy-gorse-in-kubernetes-experimental"><a class="header" href="#deploy-gorse-in-kubernetes-experimental">Deploy Gorse in Kubernetes (Experimental)</a></h2>
<p>Coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restful-apis"><a class="header" href="#restful-apis">RESTful APIs</a></h1>
<p>RESTful APIs provided by the Gorse server are listed in this section. For more detailed information, please browse the interactive API document at <code>http://&lt;server node IP&gt;:&lt;server node port&gt;/apidocs</code>.</p>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>By default, there is no authorization required for RESTful APIs. Authorization can be enabled by set <code>api_key</code> in config file:</p>
<pre><code class="language-toml">api_key = &quot;*****&quot;    # secret key for RESTful APIs (SSL required)
</code></pre>
<p>The API key is passed through <code>X-API-Key</code> header.</p>
<pre><code class="language-bash">curl -H &quot;X-API-Key: *****&quot;  http://127.0.0.1:8087/api/recommend/bob?n=10
</code></pre>
<h2 id="default-length-of-returned-list"><a class="header" href="#default-length-of-returned-list">Default Length of Returned List</a></h2>
<p>There are RESTful APIs returns collections (users, items or feedbacks). The default number of returned elements is specified in configuration file:</p>
<pre><code class="language-toml">default_n = 10  # default number of returned items
</code></pre>
<h2 id="item-apis"><a class="header" href="#item-apis">Item APIs</a></h2>
<table><thead><tr><th>Method</th><th>URL</th><th>Description</th></tr></thead><tbody>
<tr><td>POST</td><td>/item</td><td>Insert an item.<br>Overwrite if the item exists.</td></tr>
<tr><td>GET</td><td>/item/{item-id}</td><td>Get an item.</td></tr>
<tr><td>PATCH</td><td>/item/{item-id}</td><td>Modify an item.</td></tr>
<tr><td>DELETE</td><td>/item/{item-id}</td><td>Delete an item and its feedbacks.</td></tr>
<tr><td>POST</td><td>/items</td><td>Insert items. Overwrite if items exist.</td></tr>
<tr><td>GET</td><td>/items</td><td>Get items.</td></tr>
<tr><td>PUT</td><td>/item/{item-id}/category/{category}</td><td>Append a category to an item.</td></tr>
<tr><td>DELETE</td><td>/item/{item-id}/category/{category}</td><td>Delete a category from an item.</td></tr>
</tbody></table>
<h2 id="user-apis"><a class="header" href="#user-apis">User APIs</a></h2>
<table><thead><tr><th>Method</th><th>URL</th><th>Description</th></tr></thead><tbody>
<tr><td>POST</td><td>/user</td><td>Insert a user. Overwrite if the user exists.</td></tr>
<tr><td>GET</td><td>/user/{user-id}</td><td>Get a user.</td></tr>
<tr><td>PATCH</td><td>/user/{user-id}</td><td>Modify a user.</td></tr>
<tr><td>DELETE</td><td>/user/{user-id}</td><td>Delete a user and his or her feedbacks.</td></tr>
<tr><td>GET</td><td>/users</td><td>Get users.</td></tr>
</tbody></table>
<h2 id="feedback-apis"><a class="header" href="#feedback-apis">Feedback APIs</a></h2>
<table><thead><tr><th>Method</th><th>URL</th><th>Description</th></tr></thead><tbody>
<tr><td>POST</td><td>/feedback</td><td>Insert feedbacks.<br>Ignore if exists.</td></tr>
<tr><td>PUT</td><td>/feedback</td><td>Insert feedbacks.<br>Overwrite if exists.</td></tr>
<tr><td>GET</td><td>/feedback</td><td>Get feedbacks.</td></tr>
<tr><td>GET</td><td>/feedback/{feedback-type}</td><td>Get feedbacks with<br>feedback type.</td></tr>
<tr><td>GET</td><td>/feedback/{user-id}/{item-id}</td><td>Get feedbacks between<br>a user and a item.</td></tr>
<tr><td>DELETE</td><td>/feedback/{user-id}/{item-id}</td><td>Delete feedbacks between<br>a user and a item.</td></tr>
<tr><td>GET</td><td>/feedback/{feedback-type}/{user-id}/{item-id}</td><td>Get feedbacks between<br>a user and a item<br>with feedback type..</td></tr>
<tr><td>DELETE</td><td>/feedback/{feedback-type}/{user-id}/{item-id}</td><td>Delete feedbacks between<br>a user and a item<br>with feedback type..</td></tr>
<tr><td>GET</td><td>/user/{user-id}/feedback</td><td>Get feedback by user id.</td></tr>
<tr><td>GET</td><td>/user/{user-id}/feedback/{feedback-type}</td><td>Get feedbacks by user id<br>with feedback type.</td></tr>
<tr><td>GET</td><td>/item/{item-id}/feedback</td><td>Get feedback by item id.</td></tr>
<tr><td>GET</td><td>/item/{item-id}/feedback/{feedback-type}</td><td>Get feedbacks by item id<br>with feedback type.</td></tr>
</tbody></table>
<h2 id="recommendation-apis"><a class="header" href="#recommendation-apis">Recommendation APIs</a></h2>
<table><thead><tr><th>Method</th><th>URL</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td>/popular</td><td>Get popular items.</td></tr>
<tr><td>GET</td><td>/popular/{category}</td><td>Get popular items in category.</td></tr>
<tr><td>GET</td><td>/latest</td><td>Get latest items.</td></tr>
<tr><td>GET</td><td>/latest/{category}</td><td>Get latest items in category.</td></tr>
<tr><td>GET</td><td>/item/{item-id}</td><td>Get neighbors of an item.</td></tr>
<tr><td>GET</td><td>/item/{item-id}/{category}</td><td>Get neighbors of an item in category.</td></tr>
<tr><td>GET</td><td>/user/{user-id}</td><td>Get neighbors of a user.</td></tr>
<tr><td>GET</td><td>/recommend/{user-id}</td><td>Get recommendations for a user.</td></tr>
<tr><td>GET</td><td>/recommend/{user-id}/{category}</td><td>Get recommendations for a user<br>in category.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>These configuration items without default values must be filled. It's highly recommended to create a new config file based on <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template"><code>config.toml.template</code></a>.</p>
<h2 id="database"><a class="header" href="#database"><code>[database]</code></a></h2>
<p>Configurations under <code>[database]</code> are used to define behaviors on the database and data.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data_store</code></td><td>string</td><td></td><td>Database for data store (supports MySQL/PostgresSQL/ClickHouse/MongoDB) <a href="chapter_2.html">(2)</a></td></tr>
<tr><td><code>cache_store</code></td><td>string</td><td></td><td>Database for cache store (supports Redis) <a href="chapter_2.html">(2)</a></td></tr>
<tr><td><code>auto_insert_user</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new users when inserting new feedback <a href="ch02-02-feedback.html#users-items-and-feedback">(2.2)</a></td></tr>
<tr><td><code>auto_insert_item</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new items when inserting new feedback <a href="ch02-02-feedback.html#users-items-and-feedback">(2.2)</a></td></tr>
<tr><td><code>cache_size</code></td><td>string</td><td><code>100</code></td><td>Number of cached elements in cache store</td></tr>
<tr><td><code>positive_feedback_types</code></td><td>string</td><td></td><td>Types of positive feedback <a href="ch02-02-feedback.html#define-positive-feedback-and-read-feedback">(2.2)</a></td></tr>
<tr><td><code>read_feedback_type</code></td><td>string</td><td></td><td>Type of feedback for read events <a href="ch02-02-feedback.html#define-positive-feedback-and-read-feedback">(2.2)</a></td></tr>
<tr><td><code>positive_feedback_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of positive feedback <a href="ch02-04-performance.html#set-ttl-for-items-and-feedback">(2.4)</a></td></tr>
<tr><td><code>item_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of items <a href="ch02-04-performance.html#set-ttl-for-items-and-feedback">(2.4)</a></td></tr>
</tbody></table>
<p>The DSN (Database Source Name) format of the <code>data_store</code> and <code>cache_store</code> is as follows.</p>
<ul>
<li>Redis: <code>redis://hostname:port</code></li>
<li>MySQL: <code>mysql://[username[:password]@][protocol[(hostname:port)]]/database[?config1=value1&amp;...configN=valueN]</code></li>
<li>PostgresSQL: <code>postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full</code></li>
<li>ClickHouse: <code>clickhouse://user:password@host[:port]/database?param1=value1&amp;...&amp;paramN=valueN</code></li>
<li>MongoDB: <code>mongodb://[username:password@]hostname1[:port1][,... hostnameN[:portN]]][/[database][?options]]</code> or <code>mongodb+srv://[username:password@]hostname1[:port1][,... hostnameN[:portN]]][/[database][?options]]</code></li>
</ul>
<h2 id="master"><a class="header" href="#master"><code>[master]</code></a></h2>
<p>Configurations under <code>[master]</code> are used to define behaviors of the master node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td><code>&quot;127.0.0.1&quot;</code></td><td>Master node listening host for gRPC service (metadata exchange) <a href="chapter_2.html">(2)</a></td></tr>
<tr><td><code>port</code></td><td>integer</td><td><code>8086</code></td><td>Master node listening port for gRPC service (metadata exchange) <a href="chapter_2.html">(2)</a></td></tr>
<tr><td><code>http_host</code></td><td>string</td><td><code>&quot;127.0.0.1&quot;</code></td><td>Master node listening host for HTTP service (dashboard <a href="ch02-05-dashboard.html">(2.5)</a>)</td></tr>
<tr><td><code>http_port</code></td><td>integer</td><td><code>8088</code></td><td>Master node listening port for HTTP service (dashboard <a href="ch02-05-dashboard.html">(2.5)</a>)</td></tr>
<tr><td><code>n_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for the master node</td></tr>
<tr><td><code>meta_timeout</code></td><td>integer</td><td><code>60</code></td><td>Metadata timeout in seconds <a href="chapter_2.html">(2)</a></td></tr>
<tr><td><code>dashboard_user_name</code></td><td>string</td><td></td><td>Username login dashboard <a href="ch02-05-dashboard.html#login">(2.5)</a></td></tr>
<tr><td><code>dashboard_password</code></td><td>string</td><td></td><td>Password login dashboard <a href="ch02-05-dashboard.html#login">(2.5)</a></td></tr>
</tbody></table>
<h2 id="server"><a class="header" href="#server"><code>[server]</code></a></h2>
<p>Configurations under <code>[server]</code> are used to define behaviors of the server node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default_n</code></td><td>integer</td><td><code>10</code></td><td>Default number of returned items <a href="ch01-02-restful-api.html#authorization">(1.2)</a></td></tr>
<tr><td><code>api_key</code></td><td>string</td><td></td><td>Secret key for RESTful APIs (SSL required) <a href="ch01-02-restful-api.html#default-length-of-returned-list">(1.2)</a></td></tr>
</tbody></table>
<h2 id="recommend"><a class="header" href="#recommend"><code>[recommend]</code></a></h2>
<p>Configurations under <code>[recommend]</code> are used to define behaviors of recommendation.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>popular_window</code></td><td>integer</td><td><code>180</code></td><td>Time window of popular items in days <a href="ch02-03-strategy.html#latest-recommender">(2.3)</a></td></tr>
<tr><td><code>fit_period</code></td><td>integer</td><td><code>60</code></td><td>Period of model training in minutes <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>search_period</code></td><td>integer</td><td><code>180</code></td><td>Period of model search in minutes <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>search_epoch</code></td><td>integer</td><td><code>100</code></td><td>Number of training epochs for each model in model search <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>search_trials</code></td><td>integer</td><td><code>10</code></td><td>Number of trials for each model in model search <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>check_recommend_period</code></td><td>integer</td><td><code>1</code></td><td>Period to check recommendation for users in minute <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>refresh_recommend_period</code></td><td>integer</td><td><code>5</code></td><td>Period to refresh offline recommendation cache in days <a href="ch02-04-performance.html#set-training-and-recommendation-period">(2.4)</a></td></tr>
<tr><td><code>fallback_recommend</code></td><td>strings</td><td><code>[&quot;latest&quot;]</code></td><td>Source of recommendation when personalized recommendation exhausted <a href="ch02-03-strategy.html#online-strategy">(2.3)</a></td></tr>
<tr><td><code>num_feedback_fallback_item_based</code></td><td>integer</td><td><code>10</code></td><td>The number of feedback used in fallback item-based similar recommendation <a href="ch02-03-strategy.html#online-strategy">(2.3)</a></td></tr>
<tr><td><code>item_neighbor_type</code></td><td>string</td><td><code>&quot;auto&quot;</code></td><td>The type of neighbors for items <a href="ch02-03-strategy.html#item-based-similarity-recommender">(2.3)</a></td></tr>
<tr><td><code>enable_item_neighbor_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate item neighbor searching using vector index <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>item_neighbor_index_recall</code></td><td>float</td><td><code>0.8</code></td><td>Minimal recall for approximate user neighbor searching <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>item_neighbor_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate user neighbor searching vector index <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>user_neighbor_type</code></td><td>string</td><td><code>&quot;auto&quot;</code></td><td>The type of neighbors for users <a href="ch02-03-strategy.html#user-based-similarity-recommender">(2.3)</a></td></tr>
<tr><td><code>enable_user_neighbor_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate item neighbor searching using vector index <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>user_neighbor_index_recall</code></td><td>float</td><td><code>0.8</code></td><td>Minimal recall for approximate item neighbor searching <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>user_neighbor_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate item neighbor searching vector index <a href="ch02-04-performance.html#enable-clustering-index-for-similar-itemuser-searching">(2.4)</a></td></tr>
<tr><td><code>enable_latest_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable latest recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_popular_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable popular recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_user_based_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable user-based similarity recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_item_based_recommend</code></td><td>boolean</td><td><code>false</code></td><td>Enable item-based similarity recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_collaborative_recommend</code></td><td>boolean</td><td><code>true</code></td><td>Enable collaborative filtering recommendation during offline recommendation <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_collaborative_index</code></td><td>boolean</td><td><code>false</code></td><td>Enable approximate collaborative filtering recommend using vector index <a href="ch02-04-performance.html#enable-hnsw-index-for-collaborative-filtering">(2.4)</a></td></tr>
<tr><td><code>collaborative_index_recall</code></td><td>float</td><td><code>0.9</code></td><td>Minimal recall for approximate collaborative filtering recommend <a href="ch02-04-performance.html#enable-hnsw-index-for-collaborative-filtering">(2.4)</a></td></tr>
<tr><td><code>collaborative_index_fit_epoch</code></td><td>integer</td><td><code>3</code></td><td>Maximal number of fit epochs for approximate collaborative filtering recommend vector index <a href="ch02-04-performance.html#enable-hnsw-index-for-collaborative-filtering">(2.4)</a></td></tr>
<tr><td><code>enable_click_through_prediction</code></td><td>boolean</td><td><code>false</code></td><td>Enable click-though rate prediction during offline recommendation. Otherwise, results from multi-way recommendation would be merged randomly <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>explore_recommend</code></td><td>map</td><td><code>{ popular = 0.0, latest = 0.0 }</code></td><td>The explore recommendation method is used to inject popular items or latest items into recommended result <a href="ch02-03-strategy.html#offline-strategy">(2.3)</a></td></tr>
<tr><td><code>enable_positive_replacement</code></td><td>boolean</td><td><code>false</code></td><td>Replace historical items back to recommendations <a href="ch02-03-strategy.html#offline-strategy">(2.4)</a></td></tr>
<tr><td><code>positive_replacement_decay</code></td><td>float</td><td><code>0.8</code></td><td>Decay the weights of replaced items from positive feedbacks <a href="ch02-03-strategy.html#offline-strategy">(2.4)</a></td></tr>
<tr><td><code>read_replacement_decay</code></td><td>float</td><td><code>0.6</code></td><td>Decay the weights of replaced items from read feedbacks <a href="ch02-03-strategy.html#offline-strategy">(2.4)</a></td></tr>
</tbody></table>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Part of configurations can be overwritten by environment variables.</p>
<table><thead><tr><th>Configuration</th><th>Environment Variable</th></tr></thead><tbody>
<tr><td><code>database.cache_store</code></td><td><code>GORSE_CACHE_STORE</code></td></tr>
<tr><td><code>database.data_store</code></td><td><code>GORSE_DATA_STORE</code></td></tr>
<tr><td><code>master.port</code></td><td><code>GORSE_MASTER_PORT</code></td></tr>
<tr><td><code>master.host</code></td><td><code>GORSE_MASTER_HOST</code></td></tr>
<tr><td><code>master.http_port</code></td><td><code>GORSE_MASTER_HTTP_PORT</code></td></tr>
<tr><td><code>master.http_host</code></td><td><code>GORSE_MASTER_HTTP_HOST</code></td></tr>
<tr><td><code>server.n_jobs</code></td><td><code>GORSE_MASTER_JOBS</code></td></tr>
<tr><td><code>server.api_key</code></td><td><code>GORSE_SERVER_API_KEY</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitrec-the-live-demo"><a class="header" href="#gitrec-the-live-demo">GitRec, The Live Demo</a></h1>
<p><a href="https://gitrec.gorse.io/">GitRec</a>, the live demo, is developed to demonstrate the usage of the Gorse recommender system engine. A user logins in via GitHub OAuth, then repositories starred by this user before being imported to Gorse. Gorse recommends repositories to this user based on starred repositories. When this user saw a recommended repository, he or she can press ❤️ to tell GitRec that he or she like this recommendation and press ⏯️ to skip the current recommendation.</p>
<p><img src="img/gitrec.jpg" alt="gitrec" /></p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<center><img width="500" src="img/gitrec-architecture.png"/></center>
<ul>
<li><strong>Import new repositories</strong>: The trending crawler crawls trending repositories and inserts them into Gorse as new items. Since there are a huge number of repositories in GitHub, it's impossible to add all of them into GitRec. So, only trending repositories are imported.</li>
<li><strong>Import user starred repositories</strong>: The user starred crawler crawls user starred repositories and inserts them into Gorse as new feedback typed <code>star</code> when a new user signed in.</li>
<li><strong>Recommendation and feedbacks</strong>: GitRec web service pulls recommendations from Gorse and shows them to users. When a user press ❤️, the <code>like</code> feedback type will be inserted to Gorse. When ⏯️ pressed, <code>view</code> feedback type will be inserted to Gorse.</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>In GitRec, there are three types of feedbacks: <code>&quot;read&quot;</code>, <code>&quot;star&quot;</code> and <code>&quot;like&quot;</code>. <code>&quot;read&quot;</code> is the feedback type for reading events (a user skip a recommended repository). <code>&quot;like&quot;</code> is the feedback type for user press ❤️. <code>&quot;star&quot;</code> is the feedback type for user starred repositories. In <a href="https://github.com/zhenghaoz/gitrec/blob/master/etc/gorse/config.toml">etc/gorse/config.toml</a>, we add <code>&quot;like&quot;</code> and <code>&quot;star&quot;</code> to <code>positive_feedback_types</code>, and <code>&quot;read&quot;</code> to <code>read_feedback_types</code>.</p>
<pre><code class="language-toml"># feedback type for positive event
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# The feedback types for read events.
read_feedback_types = [&quot;read&quot;]
</code></pre>
<p>Other settings are the same as <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">docker/config.toml</a>.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>This project consists of frontend, backend, and crawlers. In this section, only these codes that interact with Gorse are introduced. Other codes are available in the <a href="https://github.com/zhenghaoz/gitrec">GitRec repository</a>.</p>
<ol>
<li>First thing is to wrap Gorse API as a python module (<a href="https://github.com/zhenghaoz/gitrec/blob/master/backend/gorse.py">backend/gorse.py</a>). It sends HTTP requests and handles responses using <code>requests</code>.</li>
</ol>
<pre><code class="language-python">from collections import namedtuple
from datetime import datetime
from typing import List

import requests

Success = namedtuple(&quot;Success&quot;, [&quot;RowAffected&quot;])


class GorseException(BaseException):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message


class Gorse:
    def __init__(self, entry_point):
        self.entry_point = entry_point

    def insert_feedback(
        self, feedback_type: str, user_id: str, item_id: str
    ) -&gt; Success:
        r = requests.post(
            self.entry_point + &quot;/api/feedback&quot;,
            json=[
                {
                    &quot;FeedbackType&quot;: feedback_type,
                    &quot;UserId&quot;: user_id,
                    &quot;ItemId&quot;: item_id,
                    &quot;Timestamp&quot;: datetime.now().isoformat(),
                }
            ],
        )
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def get_recommend(self, user_id: str, n: int = 1) -&gt; List[str]:
        r = requests.get(self.entry_point + &quot;/api/recommend/%s?n=%d&quot; % (user_id, n))
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_feedbacks(self, feedbacks) -&gt; Success:
        r = requests.post(self.entry_point + &quot;/api/feedback&quot;, json=feedbacks)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_item(self, item) -&gt; List[str]:
        r = requests.post(self.entry_point + &quot;/api/item&quot;, json=item)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)
</code></pre>
<ol start="2">
<li>In the code of trending crawler (<a href="https://github.com/zhenghaoz/gitrec/blob/master/backend/crawler_trending.py">backend/crawler_trending.py</a>), insert trending repositories as new items.</li>
</ol>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    trending_repos = get_trending()
    for trending_repo in trending_repos:
        gorse_client.insert_item(get_repo_info(trending_repo))
</code></pre>
<ol start="3">
<li>In the code of starred repositories crawler (<a href="https://github.com/zhenghaoz/gitrec/blob/master/backend/crawler_starred.py">backend/crawler_starred.py</a>), insert user starred repositories as <code>star</code> feedbacks.</li>
</ol>
<pre><code class="language-python">@app.task
def pull(token: str):
    g = GraphQLGitHub(token)
    stars = g.get_viewer_starred()
    gorse_client.insert_feedbacks(stars)
</code></pre>
<ol start="4">
<li>In the code of the web service backend (<a href="https://github.com/zhenghaoz/gitrec/blob/master/backend/app.py">backend/app.py</a>), pull recommendations from Gorse, insert <code>like</code> and <code>read</code> into Gorse.</li>
</ol>
<pre><code class="language-python">@app.route(&quot;/api/repo&quot;)
def get_repo():
    repo_id = gorse_client.get_recommend(session[&quot;user_id&quot;])[0]
    full_name = repo_id.replace(&quot;:&quot;, &quot;/&quot;)
    github_client = Github(github.token[&quot;access_token&quot;])
    repo = github_client.get_repo(full_name)
    # ...


@app.route(&quot;/api/like/&lt;repo_name&gt;&quot;)
def like_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;like&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)


@app.route(&quot;/api/read/&lt;repo_name&gt;&quot;)
def read_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;read&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-build-recommender"><a class="header" href="#chapter-2-build-recommender">Chapter 2: Build Recommender</a></h1>
<p>Recommender systems are complex. The overall workflow in Gorse is as follows:</p>
<center><img width="500" src="img/ch2/overview.png"></center>
<ul>
<li>Users, items and feedbacks are stored in <strong>database</strong> (a.k.a. <code>data_store</code> in config file). <a href="ch02-01-items.html">Section 2.1 Item Management</a> introduces how to manage items in Gorse. Feedbacks are required to generate personalized recommendations for user, which is discussed in <a href="http://%5B::1%5D:3000/ch02-02-feedback.html">Section 2.2 Feedback Collection</a>.</li>
<li>Latest items, popular items, user neighbors, item neighbors, recommendations and meta data are store in <strong>cache</strong> (a.k.a <code>cache_store</code> in config file).</li>
<li>The <strong>master node</strong> loads data from database. In the process of loading data, popular items and latest items are write to cache. Then, the master node search neighbors and training recommendation models. In background, random search is used to find the optimal recommendation model for current data. The <strong>worker nodes</strong> pull recommendation models from the master node and generate recommendations for each user. The <strong>server nodes</strong> provides RESTful APis. 
<ul>
<li><a href="ch02-03-strategy.html">Section 2.3 Recommendation Strategies</a> shows how to define recommendation behaviors. </li>
<li><a href="ch02-04-performance.html">Section 2.4 Performance vs Precision</a> discusses how to trade off between system performance and recommendation precision. </li>
<li>The server nodes and worker nodes synchronize meta information from the master node. The address adn timeout of meta communication are specified in config file.</li>
</ul>
</li>
</ul>
<pre><code class="language-toml">port = 8086                     # master port
host = &quot;0.0.0.0&quot;                # master host
meta_timeout = 10               # cluster meta timeout (second)
</code></pre>
<p>All data and status can be viewed in Gorse dashboard (read <a href="ch02-05-dashboard.html">Section 2.5 Gorse Dashboard</a> for more information).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-management"><a class="header" href="#item-management">Item Management</a></h1>
<p>Items are the main characters of the recommender system. This section will introduce how to manage items in Gorse, including controlling the visibility of items, describing items to the recommender system, etc.</p>
<h2 id="item-properties"><a class="header" href="#item-properties">Item Properties</a></h2>
<p>An item consists of 6 fields:</p>
<pre><code class="language-go">type Item struct {
	ItemId     string
	IsHidden   bool
	Categories []string
	Timestamp  time.Time
	Labels     []string
	Comment    string
}
</code></pre>
<ul>
<li><code>ItemId</code> is the unique identifier of the item and cannot contain a slash &quot;/&quot; because of conflicts with the URL definition of the RESTful API.</li>
<li><code>IsHidden</code> determines whether the item is hidden, after setting true, the item will no longer appear in the recommendation results.</li>
<li><code>Categories</code> is the categories to which the item belongs, the item is recommended under these categories.</li>
<li><code>Timestamp</code> is the timestamp of the item, which is used to determine the freshness of the item.</li>
<li><code>Labels</code> is the item's label information, which is used to describe the item's characteristics to the recommender system.</li>
<li><code>Comment</code> is the item's comment information, which helps to browse items and recommendation results in the dashboard.</li>
</ul>
<h2 id="item-management-1"><a class="header" href="#item-management-1">Item Management</a></h2>
<p>With the help of item fields, items can be managed flexibly.</p>
<h3 id="hide-items"><a class="header" href="#hide-items">Hide Items</a></h3>
<p>In many cases, items in the history are not available for recommendation to other users, e.g.</p>
<ul>
<li>If the item is sold out, it can't be recommended to other users.</li>
<li>If the item is legally risky, it cannot continue to be recommended to other users either.</li>
</ul>
<p>In Gorse, items can be taken down by setting <code>IsHidden</code> to <code>true</code> for the item via the RESTful API. The recommendation algorithm can use the item during training, but the item will no longer be recommended to other users. Setting <code>IsHidden</code> to <code>true</code> takes effect immediately, but setting it to <code>false</code> resumes item recommendations after the <code>refresh_recommend_period</code> has expired.</p>
<h3 id="multi-categories-recommendation"><a class="header" href="#multi-categories-recommendation">Multi-Categories Recommendation</a></h3>
<p>Multi-categories recommendations are common, take YouTube for example, where multiple recommendation categories are provided on the homepage.</p>
<p><img src="img/ch2/youtube-topics.png" alt="" /></p>
<p>Multiple categories can be distinguished by topics such as food, travel, etc., or by forms, e.g. live, short and long videos. Items will definitely appear in the global recommendation stream, and in addition the <code>Categories</code> field determines which recommendation categories the items should appear in. For each recommendation API, there are a global version and category version:</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>GET</td><td>/api/latest</td><td>Get latest items.</td></tr>
<tr><td>GET</td><td>/api/latest/{category}</td><td>Get latest items in specified category.</td></tr>
<tr><td>GET</td><td>/api/popular</td><td>Get popular items.</td></tr>
<tr><td>GET</td><td>/api/popular/{category}</td><td>Get popular items in specified category.</td></tr>
<tr><td>GET</td><td>/api/recommend/{user-id}</td><td>Get recommendation for user.</td></tr>
<tr><td>GET</td><td>/api/recommend/{user-id}/{category}</td><td>Get recommendation for user in specified category.</td></tr>
<tr><td>GET</td><td>/api/item/{item-id}/neighbors</td><td>Get neighbors of a item.</td></tr>
<tr><td>GET</td><td>/api/item/{item-id}/neighbors/{category}</td><td>Get neighbors of a item in specified category.</td></tr>
</tbody></table>
<p>For example, for a live badminton match, you can set its <code>Categories</code> to &quot;Live&quot; and &quot;Sports&quot;. In this way, in addition to the default recommendation stream, the user can find the live stream in the &quot;Live&quot; and &quot;Sports&quot; recommendation categories.</p>
<p><img src="img/ch2/youtube-live.png" alt="" /></p>
<p>Note that multi-column recommendations will consume more Redis cache space.</p>
<h3 id="using-labels-to-describe-items"><a class="header" href="#using-labels-to-describe-items">Using Labels to Describe Items</a></h3>
<p>If only the item ID is available, the recommender system has no knowledge of the item's content, which requires labels to help the recommender system understand the item.</p>
<ul>
<li><strong>User-Generated Label</strong>: Human-supplied labels are generally the most accurate and can be added by editors or users. For example, for a game, editors can add publisher and genres as labels, and users can add topics about the game as labels.</li>
<li><strong>Automatic Label Extraction</strong>: Unfortunately, in many cases, items do not have ready-made labels, so it is necessary to use machine learning to automatically generate labels for items.
<ul>
<li><strong>Image Classification</strong>: The class of image is used as a label, for example, to classify whether the image is a girl, a boy, a cat or a dog.</li>
<li><strong>Object Detection</strong>: Detect the objects contained in the image as labels, e.g. detecting the image as having a girl with a cat.</li>
<li><strong>Keyword Extraction</strong>: Extract the keywords of the text, e.g. an article talks about deep learning based recommender systems, the keywords are deep learning and recommender system.</li>
<li><strong>Text Classification</strong>: Classify the content of a article, for example, to determine whether a tweet is confiding, dating or job hunting.</li>
</ul>
</li>
</ul>
<p>Generating high-quality labels for items is a difficult task, and low-quality labels might harm the accuracy of the recommender system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-collection"><a class="header" href="#feedback-collection">Feedback Collection</a></h1>
<p>In a recommender system, data is the foundation of all recommendation results, and this section will briefly introduce how to collect user data for the Gorse recommender system. The recommender system relies on the feedback between users and items as training data, and the quality of training data determines the quality of recommendations.</p>
<h2 id="users-items-and-feedback"><a class="header" href="#users-items-and-feedback">Users, Items, and Feedback</a></h2>
<p>The recommender system is complex, but to maximize reusability, Gorse has abstracted the data used in a recommender system as a collection of three entities: users, items, and feedback.</p>
<ul>
<li><strong>User:</strong> A user entity consists of a user ID and labels describing the user. The user labels can be empty, but these labels help to improve the recommendation accuracy of the recommender system.</li>
</ul>
<pre><code class="language-go">type User struct {
    UserId    string
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item entity consists of an item ID, its visibility, its categories, an item timestamp, and labels describing the item. The timestamp and labels can be empty, and similarly based on labels information helps to improve the recommendation accuracy of the recommender system, while the timestamp is used to estimate the freshness of the item. Read <a href="ch02-01-items.html">2.2 Item Management</a> for more information about <code>IsHidden</code> and <code>Categories</code> fields.</li>
</ul>
<pre><code class="language-go">type Item struct {
	ItemId     string
	IsHidden   bool
	Categories []string
	Timestamp  time.Time
	Labels     []string
	Comment    string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback entity consists of user ID, item ID, feedback type, and feedback timestamp, where the triad of user ID, item ID, and feedback type is required to be unique in the database.</li>
</ul>
<p>Feedback represents events that happened between users and items, which can be positive or negative. For example, sharing and liking are the user's positive feedback to an item. If the user does not have further positive feedback after reading, the user's feedback on the item is considered negative. If the user views the item, read feedback will be recorded. Then, if the user gives positive feedback to the item, the read feedback will be overwritten by the positive feedback. Conversely, if the user does not give positive feedback, then the read feedback is considered negative feedback.</p>
<pre><code class="language-go">type Feedback struct {
    FeedbackType string
    UserId       string
    ItemId       string
    Timestamp    time.Time
}
</code></pre>
<p>Gorse's server node provides RESTful APIs for inserting users, items, and feedback, as well as getting a recommendation for users. Please refer to the RESTful API documentation for a detailed description.</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>POST</td><td>/api/item</td><td>Insert item.</td></tr>
<tr><td>POST</td><td>/api/user</td><td>Insert user.</td></tr>
<tr><td>POST</td><td>/api/feedback</td><td>Insert feedback if the feedback not exist.</td></tr>
<tr><td>PUT</td><td>/api/feedback</td><td>Insert feedback, and overwrites existed feedback.</td></tr>
</tbody></table>
<p>The user and item must exist when a feedback is inserted. Gorse server nodes will create new users and new items automatically according to the following configurations:</p>
<pre><code class="language-toml"># Insert new users while inserting feedback. The default value is true.
auto_insert_user = true

# Insert new items while inserting feedback. The default value is true.
auto_insert_item = true
</code></pre>
<p>Auto created users and items have ID only and other fields are all empty.</p>
<h2 id="define-positive-feedback-and-read-feedback"><a class="header" href="#define-positive-feedback-and-read-feedback">Define Positive Feedback and Read Feedback</a></h2>
<p>Before inserting feedback into the Gorse recommender system, it is necessary to define which of the user's behaviors are positive feedback and which are read feedback. Read feedback is relatively easy to define, as it can be recorded as read feedback when a user has seen the recommended item. However, the definition of positive feedback depends more on the specific scenario. For TikTok, users can be considered as positive feedback if they “like” or “share” the current video; for YouTube, users can be considered as positive feedback if they watch the video to a certain proportion of completion, “like“ the video, or &quot;share&quot; the video. To summarize, positive feedback and read feedback are defined by the following rules.</p>
<ul>
<li><strong>Read Feedback:</strong> The user sees the item.</li>
<li><strong>Positive feedback:</strong> The user action that is expected to do by the service provider.</li>
</ul>
<p>For example, if Gabe Newell wants to build a recommender system for Steam based on Gorse, clicking into the game introduction page could be treated as read feedback (the game list page has too little information to determine that the user has read it), and then actions such as adding a wish list and adding a shopping cart are treated as positive feedback. Finally, set them in the configuration file as follows.</p>
<pre><code class="language-toml"># Add to wishlist or cart
positive_feedback_types = [&quot;wish_list&quot;, &quot;cart&quot;]

# Read the game introduction page
read_feedback_types = [&quot;read&quot;]
</code></pre>
<h2 id="insert-positive-feedback"><a class="header" href="#insert-positive-feedback">Insert Positive Feedback</a></h2>
<p>For positive feedback, it can be inserted when the user performs the action, where the timestamp is the current timestamp.</p>
<pre><code class="language-bash">curl -X POST &quot;http://127.0.0.1:8088/api/feedback&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d '[ { &quot;FeedbackType&quot;: &quot;read&quot;, &quot;ItemId&quot;: &quot;10086&quot;, &quot;Timestamp&quot;: &quot;2021-10-24T06:42:20.207Z&quot;, &quot;UserId&quot;: &quot;jack&quot; }]'
</code></pre>
<h2 id="insert-read-feedback"><a class="header" href="#insert-read-feedback">Insert Read Feedback</a></h2>
<p>For read feedback, the timestamp can be used to set the timeout of the recommendation results, in addition to recording the read time.</p>
<h3 id="proactive-insertion"><a class="header" href="#proactive-insertion">Proactive Insertion</a></h3>
<p>Positive feedback can be inserted into the recommender system when the user takes the action, while read feedback requires the application to detect the user's &quot;read&quot; behavior. The methods for displaying recommendations vary by application but can be generally grouped into two categories.</p>
<ul>
<li><strong>Full-screen mode:</strong> The most typical application is TikTok, where the user is considered &quot;read&quot; when the full-screen content is shown to them. That is, the application can write a &quot;read&quot; feedback to the recommender system when the recommended content is shown to the user, and the read content will no longer be shown to the user.</li>
</ul>
<img src="/img/ch2/tiktok.jpg" width="300">
<img src="/img/ch2/youtube.jpg" width="300">
<ul>
<li><strong>List mode:</strong> The most typical application is YouTube, where the user is not considered &quot;read&quot; after looking at multiple videos in the list. When there are more than one videos, the user's attention is not able to browse the whole list. Moreover, if the read content is quickly discarded in the list mode, the recommended content is consumed too fast. Therefore, the best solution is to write a &quot;read&quot; feedback with a future timestamp to the recommender system when the item is presented to the user in the stream, and the &quot;read&quot; feedback will take effect when the time has reached the timestamp, and the read content will no longer be presented to the user.</li>
</ul>
<h3 id="automatic-insertion"><a class="header" href="#automatic-insertion">Automatic Insertion</a></h3>
<p>Proactively inserting read feedback to the recommender system requires the application to be able to accurately capture user browsing behavior. This task is easier for mobile applications but more difficult for web applications. To address this problem, Gorse's API for getting recommendation results provides two parameters: <code>write−back−type</code> and <code>write−back−delay</code>.</p>
<ul>
<li><strong>In full-screen mode:</strong> Get a recommendation and write a &quot;read&quot; feedback, the recommendation will not appear again afterward.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;n=1&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<ul>
<li><strong>In list mode:</strong> Get 10 recommendations and write &quot;read&quot; feedback with timestamps of 10 minutes later. The 10 recommendations will not be discarded until after 10 minutes.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;write-back-delay=10&amp;n=10&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<p>The <code>write−back−type</code> and <code>write−back−delay</code> parameters of the recommendation API provide a convenient way to insert read feedback, but of course, if you want the read feedback to be more accurate, it should be written to the recommender system by the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommendation-strategies"><a class="header" href="#recommendation-strategies">Recommendation Strategies</a></h1>
<p>Gorse recommender system implements different types of recommenders, both non-personalized and personalized. No single recommender is a panacea, and only a combination of them can be used to achieve the best recommendation results.</p>
<p><img src="img/ch2/workflow.png" alt="gitrec" /></p>
<h2 id="recommenders"><a class="header" href="#recommenders">Recommenders</a></h2>
<p>First, this section introduces the various types of recommenders in Gorse, each of which has its pros and cons.</p>
<h3 id="latest-recommender"><a class="header" href="#latest-recommender">Latest Recommender</a></h3>
<p>The latest recommender shows the latest items to users according to timestamps, which allows a new item to be exposed to users in time. However, the downside of the latest recommender is that it does not consider the quality (or popularity) of items. To enable the latest recommender in Gorse, you need to set timestamp information for the items. Without timestamps, Gorse will not generate a list of the latest items.</p>
<pre><code class="language-go">type Item struct {
    ItemId    string
    Timestamp time.Time // The timestamp is required.
    Labels    []string
    Comment   string
}
</code></pre>
<h3 id="popular-recommender"><a class="header" href="#popular-recommender">Popular Recommender</a></h3>
<p>Popular recommender shows the recent popular items to users, most typically Twitter trending. In Gorse, the <code>popular_window</code> in the configuration file corresponds to the window of popular items, the following example is to recommend popular items within one year (a bit too long).</p>
<pre><code class="language-toml">popular_window = 365
</code></pre>
<p>A popular recommender is not suitable to be used alone, otherwise, it would result in new items not being exposed. Many sites display content with a combination of popular and latest recommendations, such as calculating a score based on popularity and freshness and finally sorting by score.</p>
<h3 id="item-based-similarity-recommender"><a class="header" href="#item-based-similarity-recommender">Item-based Similarity Recommender</a></h3>
<p>In some scenarios, users like specific types of items, for example, gamers like to solve puzzles or users of a video platform like to watch dancing girls. Based on the user's history and the similarity between items, an item-based similarity recommender recommends items to users. The critical step of an item-based similarity recommender is to calculate the similarity between items.</p>
<p>Gorse calculates item similarity in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between items.</li>
<li><strong>Related:</strong> Calculates similarity based on user overlap between items.</li>
<li><strong>Automatic:</strong> Prefer to use labels to calculate similarity, if there are no labels then use users to calculate similarity.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for items. There are three types:
#   similar: Neighbors are found by some common labels.
#   related: Neighbors are found by some common users.
#   auto: If an item has labels, neighbors are found by some common labels.
#         If this item has no labels, neighbors are found by some common users.
# The default value is &quot;auto&quot;.
item_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because item-based similarity recommender using <code>related</code> recommends similarly to collaborative filtering recommenders. The advantage of item-based similarity (labels-based) recommender is that it can quickly recommend a new item to users who are interested in such items based on the labels. Of course, this recommender requires accurate labels for the items, and invalid labels are counterproductive.</p>
<h3 id="user-based-similarity-recommender"><a class="header" href="#user-based-similarity-recommender">User-based Similarity Recommender</a></h3>
<p>There are also common preferences among similar users. For example, students majoring in computer science usually buy books about computer science, and elders like to buy health care products.</p>
<p>Gorse calculates the similarity between users in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between users.</li>
<li><strong>Related:</strong> Calculates similarity based on historical item overlap between users.</li>
<li><strong>Automatic:</strong> Prioritizes the use of user labels, if there are no labels then the similarity is calculated using historical items.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for users. There are three types:
#   similar: Neighbors are found by some common labels.
#   related: Neighbors are found by some common liked items.
#   auto: If a user has labels, neighbors are found by some common labels.
#         If this user has no labels, neighbors are found by some common liked items.
# The default value is &quot;auto&quot;.
user_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because user-based Similarity Recommender using <code>related</code> is similar to collaborative filtering recommender. The recommender is friendly to new users. With user labels, recommendations can be generated based on similar users' preferences even if the user does not have any history.</p>
<h3 id="collaborative-filtering-recommender"><a class="header" href="#collaborative-filtering-recommender">Collaborative Filtering Recommender</a></h3>
<p>Recommenders based on similar items and similar users require that the recommended items need to be linked with similar users or historical items of the recommended user, which limits the scope of recommended items searching. The collaborative filtering recommender in Gorse uses matrix factorization<sup class="footnote-reference"><a href="#1">1</a></sup><sup class="footnote-reference"><a href="#2">2</a></sup> to recommend items. The training algorithm maps users and items to embedding vectors in a high-dimensional space, and the user's preference for an item is the dot product of the user embedding vector and the item embedding vector. However, the disadvantage of collaborative filtering recommender is that it cannot utilize the label information of users and items, and it cannot handle new users and new items.</p>
<h3 id="click-through-rate-prediction"><a class="header" href="#click-through-rate-prediction">Click-through Rate Prediction</a></h3>
<p>Is there a recommender that combines the advantages of similarity recommender and collaborative filtering recommender? Then it is the click-through rate, prediction model. The click-through rate prediction model in Gorse is a factorization machine<sup class="footnote-reference"><a href="#3">3</a></sup> that generates embedding vectors for each user label and item label in addition to embedding vectors for each user and item. Although the factorization machine model is effective, it is not generally used as a recommender for collecting recommended items over all items. Compared with collaborative filtering recommender and similarity recommender, its computational complexity is large. Gorse's click-through prediction model is used to fuse and rank the results of the above recommenders.</p>
<p>The original meaning of &quot;click-through rate prediction&quot; is to predict the probability that users will click on the recommended content or ads, but it should be noted that the click-through rate prediction in Gorse refers more to the probability that users will give positive feedback to the recommended results. For example, suppose we set in Gorse that positive feedback means the user has watched 50% of the video, then the &quot;click-through rate&quot; is the probability that the user has watched more than 50% of the video.</p>
<h2 id="recommendation-strategy"><a class="header" href="#recommendation-strategy">Recommendation Strategy</a></h2>
<p>Individual recommenders cannot perform the recommendation task well, and multiple recommenders need to be combined. Gorse provides a workflow for generating recommendation results, under which we can draft recommendation strategies that are suitable for specific scenarios. The recommendation process consists of two main components: offline recommendation and online recommendation. The offline recommendation collects recommendations for each user from the full set of items and caches them in Redis. The online recommendation pulls the cached recommendation results, then removes the read content from the recommendation results, and if the cached recommendation results are exhausted, then the recommendation content is generated in real-time using the fallback recommenders.</p>
<h3 id="offline-strategy"><a class="header" href="#offline-strategy">Offline Strategy</a></h3>
<p>Offline recommendation consists of four phases.</p>
<ul>
<li><strong>Matching:</strong> Use different full-set recommenders to collect recommended items from all items. There are five types of full-set recommenders: popular recommender, latest recommender, item-based similarity recommender, user-based similarity recommender, and collaborative filtering recommender, which can be set on or off in the configuration file.</li>
<li><strong>Ranking:</strong> Use the factorization machine model to rank the items collected by the matching phase, currently you can also turn off the click-through rate prediction in the configuration and use random merge.</li>
<li><strong>Replacement:</strong> In some cases, read items should be recommended to users again but with lower priorities. If <code>enable_replacement</code> is set, read items would be replaced back to recommendations. The priority decay factors for positive feedbacks and read feedbacks are controlled by <code>positive_replacement_decay</code> and <code>read_replacement_decay</code>.</li>
<li><strong>Exploration:</strong> Recommend content based on user history can be a good idea for users, but it also limits the possibility of users seeing more diverse content. It is also a kind of &quot;exploration and exploitation&quot; problem, where exploitation refers to recommending content based on users' historical behavior, while exploration refers to exposing users to more content beyond their awareness. One of the easiest ways to expose users to content beyond the information cocoon is to insert random items into the recommendation list, and Gorse can be configured to randomly insert the newest or recent popular items into the recommendation list, with their proportion set in the configuration file.</li>
</ul>
<pre><code class="language-toml"># Enable latest recommendation during offline recommendation. The default values is false.
enable_latest_recommend = true

# Enable popular recommendation during offline recommendation. The default values is false.
enable_popular_recommend = false

# Enable user-based similarity recommendation during offline recommendation. The default values is false.
enable_user_based_recommend = true

# Enable item-based similarity recommendation during offline recommendation. The default values is false.
enable_item_based_recommend = false

# Enable collaborative filtering recommendation during offline recommendation. The default values is true.
enable_collaborative_recommend = true

# Enable click-though rate prediction during offline recommendation. Otherwise, results from multi-way recommendation
# would be merged randomly. The default values is true.
enable_click_through_prediction = true

# The explore recommendation method is used to inject popular items or latest items into recommended result:
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# The default values is { popular = 0.0, latest = 0.0 }.
explore_recommend = { popular = 0.1, latest = 0.2 }

# Replace historical items back to recommendations.
enable_replacement = false

# Decay the weights of replaced items from positive feedbacks.
positive_replacement_decay = 0.8

# Decay the weights of replaced items from read feedbacks.
read_replacement_decay = 0.6
</code></pre>
<p>Perhaps the introduction of various recommenders is not intuitive enough, you can preview the recommendation results in the dashboard. The popular items and the latest items can be seen on the landing page of the dashboard.</p>
<p><img src="img/ch2/latest-and-popular.png" alt="latest-and-popular" /></p>
<p>The results of offline recommendation, item-based similarity recommendation, user-based similarity recommendation, and collaborative filtering recommendation can be viewed on the user page by clicking <em>Insight</em>:</p>
<ul>
<li>Click <em>Users</em> in the navigation bar</li>
<li>Click <em>Insight</em> in the user row</li>
</ul>
<p>You can choose to show offline recommendation results, similarity item recommendation, similar user recommendation, and collaborative filtering recommendation results from the drop-down menu on the right side</p>
<p><img src="img/ch2/users.png" alt="users" /></p>
<p><img src="img/ch2/user-insight.png" alt="user-insight" /></p>
<p>Since Gorse does not yet offer A/B testing, the preview is needed to sensitively draft a recommendation strategy.</p>
<h3 id="online-strategy"><a class="header" href="#online-strategy">Online Strategy</a></h3>
<p>Online recommendations have three tasks.</p>
<ul>
<li><strong>Remove reads:</strong> The read items in the recommendation result cache need to be removed.</li>
<li><strong>Fallback:</strong> There might be a situation where the cached recommendation results are drained out but new offline recommendations haven't been generated, then the fallback recommenders are needed to generate the recommendation content in real-time. The fallback recommenders can be configured in the configuration file with priority from head to tail, and if the front recommender is no longer able to generate a recommendation, then continue to try the backward recommender.</li>
</ul>
<pre><code class="language-toml"># The fallback recommendation method for cold-start users:
#   item_based: Recommend similar items to cold-start users.
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# The default values is [&quot;latest&quot;].
fallback_recommend = [&quot;item_based&quot;, &quot;latest&quot;]
</code></pre>
<p>The fallback version of item-based similarity recommendation limit the number of feedbacks used. Only most recent <code>num_feedback_fallback_item_based</code> items are used which is set by configuration.</p>
<pre><code class="language-toml"># The number of feedback used in fallback item-based similar recommendation. The default values is 10.
num_feedback_fallback_item_based = 10
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Rendle, Steffen, et al. &quot;BPR: Bayesian personalized ranking from implicit feedback.&quot; Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence. 2009.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>He, Xiangnan, et al. &quot;Fast matrix factorization for online recommendation with implicit feedback.&quot; Proceedings of the 39th International ACM SIGIR conference on Research and Development in Information Retrieval. 2016.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Rendle, Steffen. &quot;Factorization machines.&quot; 2010 IEEE International conference on data mining. IEEE, 2010.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-vs-precision"><a class="header" href="#performance-vs-precision">Performance vs Precision</a></h1>
<p>In the most ideal situation, a recommender system should recommend to users the items they are most likely to like. However, since computation and storage resources are always limited, recommender systems often have to make tradeoffs between performance and accuracy. In this section, we describe how to configure the tradeoff between Gorse's computational resource usage, storage resource usage, and recommendation accuracy.</p>
<h2 id="set-ttl-for-items-and-feedback"><a class="header" href="#set-ttl-for-items-and-feedback">Set TTL for Items and Feedback</a></h2>
<p>By default, Gorse loads all the data in the database as training data. In the configuration file, the number of items and feedbacks read can be limited by <code>item_ttl</code> and <code>positive_feedback_ttl</code>. If the timestamp of an item is more than <code>item_ttl</code> days ago, Gorse does not read this item anymore. If the timestamp of a feedback is more than <code>positive_feedback_ttl</code> days ago, then Gorse will also not read this feedback. The advantages and disadvantages of using TTL are as follows.</p>
<ul>
<li><strong>Advantages:</strong> Remove obsolete items and feedbacks to reduce the amount of data Gorse needs to process. Items that are too outdated, such as old news, are not recommended, and user histories that are too old do not reflect current user interests, so removing outdated items and feedback is beneficial to the recommender system.</li>
<li><strong>Disadvantage:</strong> If the TTL is set decisively, the amount of information obtained during the training will be insufficient.</li>
</ul>
<p>The TTL is used to remove obsolete items and feedback, but should be set long enough to prevent loss of information.</p>
<pre><code class="language-toml"># The time-to-live (days) of positive feedback, 0 means disabled. The default value is 0.
positive_feedback_ttl = 0

# The time-to-live (days) of items, 0 means disabled. The default value is 0.
item_ttl = 0
</code></pre>
<h2 id="set-training-and-recommendation-period"><a class="header" href="#set-training-and-recommendation-period">Set Training and Recommendation Period</a></h2>
<p>There are three loops in the Gorse recommender system, which are</p>
<ul>
<li>
<p><strong>Model training loop:</strong> The master node loads data, uses the latest data to train the recommendation model, and updates the latest items, popular items, similar items, similar users, etc. The interval of the model training loop corresponds to <code>fit_period</code> in the configuration file.</p>
</li>
<li>
<p><strong>Model tuning loop:</strong> the master node loads data and uses random search<sup class="footnote-reference"><a href="#1">1</a></sup> to find the best hyper-parameters for the recommendation model. The loop interval is set by <code>search_period</code>, and the interval of the model tuning loop can be set longer. The optimal model hyper-parameters are relatively stable unless the dataset changes dramatically.</p>
<p>The model tuning loop </p>
</li>
</ul>
<pre><code>for every `search_period` minutes:
    pull data from database.
    for every recommendation models:
        for `search_trials` trials:
            sample a hyperparameter combination.
            train model with sampled hyper-parameters by `search_epoch` epoches and `search_jobs` jobs.
            update best model.
</code></pre>
<ul>
<li><strong>Recommendation loop:</strong> The worker node checks whether update each user's recommendation results, the check interval is <code>check_recommend_period</code> minutes. The conditions to update a user's recommendation are: the last active time of the user exceeds the last recommendation generated time, or the last recommendation generated time is more than <code>refresh_recommend_period</code> days from now. The interval <code>check_recommend_period</code> for checking recommendation results should be set relatively short, recommended to be around a few minutes, so as to be able to cope with the user's recommendation result consumption.</li>
</ul>
<p>Too long a interval will result in outdated models and recommendation results, and too short a interval will result in high database and cache load. In summary, <code>check_recommend_period</code> should be small, <code>search_period</code> should be large, and <code>fit_period</code> needs to be set reasonably according to the database load.</p>
<pre><code class="language-toml"># The time period for model fitting (minutes). The default values is 60.
fit_period = 360

# The time period for model searching (minutes). The default values is 100.
search_period = 60

# The number of epochs for model searching. The default values is 100.
search_epoch = 100

# The number of trials for model searching. The default values is 10.
search_trials = 10

# The time period to refresh recommendation for inactive users (days). The default values is 5.
refresh_recommend_period = 1
</code></pre>
<h2 id="enable-clustering-index-for-similar-itemuser-searching"><a class="header" href="#enable-clustering-index-for-similar-itemuser-searching">Enable Clustering Index for Similar Item/User Searching</a></h2>
<p>Gorse searches similar items for each item and similar users for each user. Assuming there are N items, the computation complexity to search similar items for an item is \(O(N)\), and the computation complexity to generate similar items for all items is \(O(N^2)\). Gorse provides a cluster-based index to speed up the searching of similar items and similar users. The index of similar items (users) first clusters items (users) according to their similarity, that is, the most similar items (users) are grouped into multiple clusters. When searching similar items (users), first find the K clusters whose centroids are most similar to the current item (user), and then search similar items (users) within the K clusters, the idea of clustering index is derived from<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>Similar item (user) index can be switched on and off by <code>enable_item_neighbor_index</code> (<code>enable_user_neighbor_index</code>), which is turned off by default in the current version and considered to be turned on by default in subsequent versions. Similar item (user) index needs to set the parameter K, which is the number of clusters to query. Too small K will cause the index to fail to reach the required recall, while too large K will reduce the performance. The construction process tries to increase K. If the query recall reaches <code>item_neighbor_index_recall</code> (<code>user_neighbor_index_recall</code>), or the growth epochs reaches <code>item_neighbor_index_fit_epoch</code> (<code>user_neighbor_ index_fit_epoch</code>), the build process stops increasing K. </p>
<pre><code class="language-toml"># Enable approximate item neighbor searching using vector index.
enable_item_neighbor_index = true

# Minimal recall for approximate item neighbor searching.
item_neighbor_index_recall = 0.8

# Maximal number of fit epochs for approximate item neighbor searching vector index.
item_neighbor_index_fit_epoch = 3

# Enable approximate user neighbor searching using vector index.
enable_user_neighbor_index = true

# Minimal recall for approximate user neighbor searching.
user_neighbor_index_recall = 0.8

# Maximal number of fit epochs for approximate user neighbor searching vector index.
user_neighbor_index_fit_epoch = 3
</code></pre>
<p>The advantages and disadvantages of using similar item/user indexing are as follows. </p>
<ul>
<li><strong>Advantages:</strong> Saves similar item/user search time.</li>
<li><strong>Disadvantages:</strong> Indexing requires extra memory, and if the data is difficult to cluster (e.g. randomly generated data), the indexing recall will be low.</li>
</ul>
<p>The recall of similar users index and similar items index can be seen in &quot;User Neighbor Index Recall&quot; and &quot;Item Neighbor Index Recall&quot; in the system status section in the overview page of Gorse dashboard.</p>
<center><img width="420px" src="img/ch3/neighbor_index_recall.jpeg"></center>
<h2 id="enable-hnsw-index-for-collaborative-filtering"><a class="header" href="#enable-hnsw-index-for-collaborative-filtering">Enable HNSW Index for Collaborative Filtering</a></h2>
<p>Collaborative filtering models in Gorse represent users and items as embedding vectors. For each user, items with large dot products of embedding vectors with the user are filtered as recommended items. Therefore, the most intuitive way to search for recommended items is to scan all items, calculate the dot product of embedding vectors during the scanning process, and select the top several items with the largest dot products as the recommended result. Assuming that there are N users and M items, the computational complexity to generate recommendation results for all users is \(O(MN)\). However, if the number of items and users is large, the overall computation is unacceptable.</p>
<p>A more efficient approach is to use the vector index HNSW<sup class="footnote-reference"><a href="#3">3</a></sup>. The HNSW index creates a navigation graph for all item vectors. The results from HNSW are not accurate, but the small loss in recall is worth the large performance gain. The HNSW requires a parameter, <code>ef_construction</code>, to be set. <code>ef_construction</code> that is too small will prevent the vector index from reaching the required recall, and <code>ef_construction</code> that is too large will reduce search performance. The build process tries to keep increasing <code>ef_construction</code>, and stops growing <code>ef_construction</code> if the recall reaches <code>collaborative_index_recall</code>, or if the number of epochs reaches <code>collaborative_index_fit_epoch</code>.</p>
<pre><code class="language-toml"># Enable approximate collaborative filtering recommend using vector index.
enable_collaborative_index = false

# Minimal recall for approximate collaborative filtering recommend.
collaborative_index_recall = 0.9

# Maximal number of fit epochs for approximate collaborative filtering recommend vector index.
collaborative_index_fit_epoch = 3
</code></pre>
<p>The advantages and disadvantages of using vector indexing for collaborative filtering are as follows.</p>
<ul>
<li><strong>Advantages:</strong> Vector indexing can significantly improve the speed of collaborative filtering recommendations and the recall is sufficient in most cases.</li>
<li><strong>Disadvantages:</strong> Creating HNSW indexes requires additional memory space and can produce relatively low recall in rare cases.</li>
</ul>
<p>The HNSW index recall of collaborative filtering corresponds to the &quot;Matching Index Recall&quot; in the system status of the dashboard overview page, if the value is low then consider turning off the index query.</p>
<center><img width="420px" src="img/ch3/cf_index_recall.jpeg"></center>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Bergstra, James, and Yoshua Bengio. &quot;Random search for hyper-parameter optimization.&quot; Journal of machine learning research 13.2 (2012).</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Auvolat, Alex, et al. &quot;Clustering is efficient for approximate maximum inner product search.&quot; arXiv preprint arXiv:1507.05910 (2015).</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Malkov, Yu A., and Dmitry A. Yashunin. &quot;Efficient and robust approximate nearest neighbor search using hierarchical navigable small world graphs.&quot; IEEE transactions on pattern analysis and machine intelligence 42.4 (2018): 824-836.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gorse-dashboard"><a class="header" href="#gorse-dashboard">Gorse Dashboard</a></h1>
<p>Gorse's master node provides the Gorse Dashboard, which can be accessed through HTTP port (the default values is <code>8088</code>)) of the master node. The HTTP port is specified in configuration file <a href="ch01-03-config.html#master">(1.3)</a>. The dashboard allows you to observe the current status of the recommender system, preview user recommendation results, and import and export data.</p>
<h2 id="login"><a class="header" href="#login">Login</a></h2>
<p>The default configuration allows access to the console without logging in. In the configuration file, the username and password to log in to the dashboard can be set.</p>
<pre><code class="language-toml">dashboard_user_name = &quot;admin&quot;   # dashboard user name
dashboard_password = &quot;password&quot; # dashboard password
</code></pre>
<p>After setting a username and password, you will be redirected to the login page the first time you access the dashboard.</p>
<center><img width="360" src="img/ch3/gorse-dashboard-login.png"></center>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The top part of the overview page shows the number of users, items, feedback, valid positive feedback and valid negative feedback in Gorse. The middle part of the overview page shows the proportion of each positive feedback given by users over time, and the curve of the corresponding feedback can be hidden by clicking on the feedback type label. The bottom part of the overview page shows the popular items and the latest items in the system, as well as other status in the system.</p>
<p><img src="img/ch3/gorse-dashboard-overview.png" alt="" /></p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>The task page displays the tasks in Gorse, including the task name, task status, task start time, task end time, and task progress.</p>
<p><img src="img/ch3/gorse-dashboard-tasks.png" alt="" /></p>
<h2 id="cluster"><a class="header" href="#cluster">Cluster</a></h2>
<p>The cluster page lists nodes in the cluster, displaying information such as node type, node name, node IP and address for APIs and metrics. If a container orchestration tool is used, the node IP may not be accessible externally.</p>
<p><img src="img/ch3/gorse-dashboard-cluster.png" alt="" /></p>
<h2 id="users"><a class="header" href="#users">Users</a></h2>
<p>The user page lists all users currently present in Gorse and can be searched by user ID. The information displayed includes the user ID, user labels, last active time and last update time of recommendation.</p>
<p><img src="img/ch3/gorse-dashboard-users.png" alt="" /></p>
<p>Click on &quot;Neighbors&quot; to see similar users of this user.</p>
<p><img src="img/ch3/gorse-dashboard-similar-users.png" alt="" /></p>
<p>Click on &quot;Insight&quot; to see the user's history and the recommendations Gorse has generated for this user.</p>
<p><img src="img/ch3/gorse-dashboard-user-insight.png" alt="" /></p>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<p>The item page lists all items currently in Gorse and can be searched by item ID. The information displayed includes the item ID, item categories, whether it is hidden or not, timestamp, item labels and item description.</p>
<p><img src="img/ch3/gorse-dashboard-items.png" alt="" /></p>
<p>Click on &quot;Neighbors&quot; to see the similar items for each item.</p>
<p><img src="img/ch3/gorse-dashboard-similar-items.png" alt="" /></p>
<h2 id="data-export-and-import"><a class="header" href="#data-export-and-import">Data Export and Import</a></h2>
<p>The advance page allows importing and exporting data.</p>
<ul>
<li>The &quot;Export Users&quot; button exports users to a CSV file with the format of user ID, user labels.</li>
<li>The &quot;Export Items&quot; button exports items to a CSV file with the format of item ID, hidden or not, item categories, timestamp, item labels and item description.</li>
<li>The &quot;Export Feedback&quot; button exports feedbacks to a CSV file in the format of feedback type, user ID, item ID and timestamp.</li>
</ul>
<p><img src="img/ch3/gorse-dashboard-advance.png" alt="" /></p>
<ul>
<li>The &quot;Import Users&quot; button allows you to enter the &quot;Import Users&quot; page and preview the imported data after selecting the file. You can set the field separator, label separator, the mapping of each field and the existence of header row. Once the settings are correct, you can click &quot;Confirm Import&quot; to complete the data import.</li>
</ul>
<p><img src="img/ch3/gorse-dashboard-import-users.png" alt="" /></p>
<ul>
<li>The &quot;Import Items&quot; button allows you to enter the &quot;Import Items&quot; page, which operates with the same logic as the &quot;Import Users&quot; page.</li>
</ul>
<p><img src="img/ch3/gorse-dashboard-import-items.png" alt="" /></p>
<ul>
<li>The &quot;Import Feedback&quot; button allows you to enter the &quot;Import Feedback&quot; page, with the same logic as for importing users.</li>
</ul>
<p><img src="img/ch3/gorse-dashboard-import-feedback.png" alt="" /></p>
<h2 id="configurations"><a class="header" href="#configurations">Configurations</a></h2>
<p>The settings page shows the configurations currently used by Gorse. The configurations used by the system are determined by a combination of the configuration file, command line options, and environment variables, so there may be differences between the configurations seen on the settings page and the configuration file used.</p>
<p><img src="img/ch3/gorse-dashboard-settings.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-monitoring"><a class="header" href="#chapter-3-monitoring">Chapter 3: Monitoring</a></h1>
<p>For an online system in production, &quot;observability&quot; is important. Real-time monitoring of an online system can identify flaws or performance issues before they affect users on a large scale. This chapter will introduce how to monitor the Gorse recommender system for logs and metrics, with the logs capturing abnormal events and the metrics monitoring observing the performance of the system. This chapter will only introduce some key configurations, for a complete configuration sample please refer to the official demo project <a href="https://github.com/zhenghaoz/gitrec">GitRec</a>.</p>
<p>The overview architecture of monitoring infrastructure is as follows:</p>
<ul>
<li>Gorse nodes write logs to log files.</li>
<li><strong>Promtail</strong> reads logs from the file and pushes them to <strong>Loki</strong>.</li>
<li><strong>Prometheus</strong> scrapes metrics from Gorse nodes.</li>
<li><strong>Grafana</strong> visualizes logs from <strong>Loki</strong> and metrics from <strong>Prometheus</strong> in dashboards.</li>
</ul>
<p><a href="ch03-01-logging.html">Section 3.1 Log Monitoring</a> introduces how to monitor logs from Gorse recommender system. <a href="ch03-02-metrics.html">Section 3.2 Metrics Monitoring</a> shows how to monitoring metrics exported by Gorse.</p>
<img src="img/ch3/monitoring.png" width="600">
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-monitoring"><a class="header" href="#log-monitoring">Log Monitoring</a></h1>
<p>The mainstream log monitoring solutions are ELK and Loki. Loki is chosen in this section because it is more lightweight compared to ELK. The log collection and monitoring process is as follows.</p>
<ul>
<li>Gorse nodes write the logs to a file.</li>
<li>Promtail reads the logs from the file and pushes them to Loki.</li>
<li>Grafana reads the logs from Loki for visualization.</li>
</ul>
<p>First, you need to set each node to write logs to a file in <code>docker-compose.yml</code>, as well as add Promtail, Loki, and Grafana.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  worker:
    image: zhenghaoz/gorse-worker
    restart: unless-stopped
    ports:
      - 8089:8089
    command: &gt;
      --master-host master 
      --master-port 8086 
      --http-host 0.0.0.0 
      --http-port 8089
      --log-path /var/log/gorse/worker.log 
      --cache-path /var/lib/gorse/worker_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - worker_data:/var/lib/gorse
    depends_on:
      - master

  server:
    image: zhenghaoz/gorse-server
    restart: unless-stopped
    ports:
      - 8087:8087
    command: &gt;
      --master-host master 
      --master-port 8086 
      --http-host 0.0.0.0 
      --http-port 8087
      --log-path /var/log/gorse/server.log 
      --cache-path /var/lib/gorse/server_cache.data
    volumes:
      - gorse_log:/var/log/gorse
      - server_data:/var/lib/gorse
    depends_on:
      - master

  master:
    image: zhenghaoz/gorse-master
    restart: unless-stopped
    ports:
      - 8086:8086
      - 8088:8088
    command: &gt;
      -c /etc/gorse/config.toml 
      --log-path /var/log/gorse/master.log 
      --cache-path /var/lib/gorse/master_cache.data
    volumes:
      - ./etc/gorse/config.toml:/etc/gorse/config.toml
      - gorse_log:/var/log/gorse
      - master_data:/var/lib/gorse
    depends_on:
      - redis
      - mysql

  grafana:
    image: grafana/grafana
    restart: unless-stopped
    ports:
      - 3000:3000
    volumes:
      - grafana-storage:/var/lib/grafana

  loki:
    image: grafana/loki
    restart: unless-stopped
    command: -config.file=/etc/loki/local-config.yaml
    ports:
      - 3100:3100
    volumes:
      - ./etc/loki/local-config.yaml:/etc/loki/local-config.yaml

  promtail:
    image: grafana/promtail
    restart: unless-stopped
    command: -config.file=/etc/promtail/config.yml
    ports:
      - 9080:9080
    volumes:
      - gorse_log:/var/log/gorse
      - ./etc/promtail/config.yml:/etc/promtail/config.yml

# ...

volumes:
  mysql_data:
  worker_data:
  server_data:
  master_data:
  gorse_log:
  grafana-storage:
</code></pre>
<p>Loki's configuration file <code>local-config.yaml</code> is as follows.</p>
<pre><code class="language-yaml">auth_enabled: false

server:
  http_listen_port: 3100

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
    final_sleep: 0s
  chunk_idle_period: 5m
  chunk_retain_period: 30s

schema_config:
  configs:
    - from: 2020-05-15
      store: boltdb
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 168h

storage_config:
  boltdb:
    directory: /tmp/loki/index

  filesystem:
    directory: /tmp/loki/chunks

limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h
</code></pre>
<p>The configuration file for Promtail is as follows.</p>
<pre><code class="language-yaml">server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /var/log/positions.yaml # This location needs to be writeable by Promtail.

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: system
    static_configs:
    - targets:
        - localhost
      labels:
        job: master
        __path__: /var/log/gorse/master.log
    - targets:
        - localhost
      labels:
        job: worker
        __path__: /var/log/gorse/worker.log
    - targets:
        - localhost
      labels:
        job: server
        __path__: /var/log/gorse/server.log
    pipeline_stages:
    - json:
        expressions:
          level: level
    - labels:
        level:
</code></pre>
<p>After deploying <code>docker-compose.yml</code>, login to Grafana and add Loki as a data source:</p>
<img src="img/ch3/loki.png" width="500">
<p>Finally, import the logs dashboard provided in the demo project GitRec to monitor warnings, errors, and fatal logs in the recommender system in real-time.</p>
<img src="img/ch3/dashboard-logs-json.png" width="500">
<p>The logs dashboard filters warning, error, and fatal logs.</p>
<ul>
<li><strong>Warning:</strong> Events affect the outcome of the recommender system, but the system has a strategy to deal with them.</li>
<li><strong>Error:</strong> Events affect the function of the system, but the system is still able to continue.</li>
<li><strong>Fatal:</strong> Events prevent the system from continuing to run.</li>
</ul>
<p>Log entries such as database temporarily connection lost, network temporarily timeout, etc. are expected. If an error log is generated that is not expected, welcome to paste it on <a href="https://github.com/zhenghaoz/gorse/issues">GitHub Issues</a>.</p>
<p><img src="/img/ch3/dashboard-logs-preview.jpeg" alt="dashboard-logs-preview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-monitoring"><a class="header" href="#metrics-monitoring">Metrics Monitoring</a></h1>
<p>Gorse nodes export Prometheus metrics, and Prometheus can scrape real-time metrics via HTTP from each node. The default HTTP port for worker nodes is <code>8089</code>, the default HTTP port for server nodes is <code>8087</code>, and the default HTTP port for master nodes is <code>8088</code>. The HTTP port for worker and server nodes can be set via the command line option <code>--http-port</code> <a href="ch01-01-deploy.html#command-line-flags">(1.1)</a>. The HTTP port for the master node is specified in configuration file <a href="ch01-03-config.html#master">(1.3)</a>.</p>
<p>The Prometheus configuration file for scraping Gorse metrics is as follows.</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name:       'gorse'
    scrape_interval: 10s
    static_configs:
      - targets: ['worker:8089', 'server:8087', 'master:8088']
</code></pre>
<p><code>scrape_interval</code> is the scraping frequency and <code>targets</code> is the address to scrape the metrics. Since the above configuration file is used for Docker Compose deployments, the hostname is used instead of the IP address. Next, add an instance of Prometheus to <code>docker-compose.yml</code>, mount the above configuration file to the default configuration file path <code>/etc/prometheus/prometheus.yml</code>.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:

  prometheus:
    image: prom/prometheus
    restart: unless-stopped
    ports:
      - 9090:9090
    volumes:
      - ./etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
</code></pre>
<p>After Prometheus started, add Prometheus as a data source in Grafana.</p>
<img src="img/ch3/prometheus.png" width="500">
<p>Finally, import dashboards provided in the demo project GitRec to monitor the count and latency of each service call on the database, cache, worker node, server node, and master node in real-time.</p>
<img src="img/ch3/dashboard-json.png" width="500">
<p>The left side of the dashboard shows the count of calls per ten minutes, while the right side shows the call latency within 99%.</p>
<p><img src="img/ch3/dashboard-cache.png" alt="dashboard-cache" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-developers-guide"><a class="header" href="#chapter-4-developers-guide">Chapter 4: Developer's Guide</a></h1>
<p>This chapter will show how to work on Gorse source code.</p>
<h2 id="setup-develop-environment"><a class="header" href="#setup-develop-environment">Setup Develop Environment</a></h2>
<p>These following installations are required:</p>
<ul>
<li><strong>Go</strong> (&gt;= 1.17): Since Go features from 1.17 are used in Gorse, the version of the compiler must be greater than 1.17. GoLand or Visual Studio Code is highly recommended as the IDE to develop Gorse.</li>
<li><strong>Docker Compose</strong>: Multiple databases are required for unit tests. It's convenient to manage databases on Docker Compose. </li>
</ul>
<pre><code class="language-bash">cd misc/database_test
docker-compose up -d
</code></pre>
<h2 id="run-unit-tests"><a class="header" href="#run-unit-tests">Run Unit Tests</a></h2>
<p>Most logics in Gorse are covered by unit tests. Run unit tests by the following command:</p>
<pre><code class="language-bash">go test -v ./...
</code></pre>
<p>The default database URLs are directed to these databases in <code>misc/database_test/docker-compose.yml</code>. Test databases could be overrode by setting following environment variables:</p>
<table><thead><tr><th>Environment Value</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>MYSQL_URI</code></td><td><code>mysql://root:password@tcp(127.0.0.1:3306)/</code></td></tr>
<tr><td><code>POSTGRES_URI</code></td><td><code>postgres://gorse:gorse_pass@127.0.0.1/</code></td></tr>
<tr><td><code>MONGO_URI</code></td><td><code>mongodb://root:password@127.0.0.1:27017/</code></td></tr>
<tr><td><code>CLICKHOUSE_URI</code></td><td><code>clickhouse://127.0.0.1:8123/</code></td></tr>
<tr><td><code>REDIS_URI</code></td><td><code>redis://127.0.0.1:6379/</code></td></tr>
</tbody></table>
<p>For example, use TiDB as a test database by:</p>
<pre><code class="language-bash">MYSQL_URI=mysql://root:password@tcp(127.0.0.1:4000)/ go test -v ./...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>These frequent asked questions are collected from issues, emails and chats. Feel free to ask more questions via <a href="https://github.com/zhenghaoz/gorse/issues">issue</a>, <a href="support@gorse.io">email</a>, <a href="https://discord.com/channels/830635934210588743/">Discord</a> (for English) or <a href="https://qm.qq.com/cgi-bin/qm/qr?k=lOERnxfAM2U2rj4C9Htv9T68SLIXg6uk&amp;jump_from=webapi">QQ</a> (for Chinese).</p>
<h3 id="1-how-to-address-the-cold-start-problem"><a class="header" href="#1-how-to-address-the-cold-start-problem">1. How to address the cold-start problem?</a></h3>
<p>Use <code>explore_recommend</code> to inject the latest items or recently popular items into a recommendation. Also, item labels are helpful to rank new items in a recommendation. For example:</p>
<pre><code class="language-toml">explore_recommend = { popular = 0.1, latest = 0.2 }
</code></pre>
<p>It means latest items are inserted into recommended items list in a probability of 0.1 and recently popular items are inserted into recommended items list in a probability of 0.2.</p>
<h3 id="2-how-to-keep-track-of-items-recommended-to-each-user"><a class="header" href="#2-how-to-keep-track-of-items-recommended-to-each-user">2. How to keep track of items recommended to each user?</a></h3>
<p>There are two options:</p>
<ol>
<li>Insert read-type feedback to Gorse when an item is shown to a user. This is the way the official demo <a href="https://github.com/zhenghaoz/gitrec">zhenghaoz/gitrec</a> tracks user-seen recommendations.</li>
<li>Use <code>write-back-type</code> and <code>write-back-delay</code> parameter to write back recommendations as read feedbacks to Gorse, eg:</li>
</ol>
<pre><code class="language-bash">curl -i -H &quot;Accept: application/json&quot; \
    -X GET http://127.0.0.1:8088//api/recommend/0?write-back-type=read&amp;write-back-delay=10
</code></pre>
<p>The 1st option is more accurate since it is done by the front end but the 2nd option is more convenient. Read <a href="ch02-03-strategy.html">2.3 Recommendation Strategies</a> for detailed information.</p>
<h3 id="3-what-does-no-feedback-found-mean"><a class="header" href="#3-what-does-no-feedback-found-mean">3. What does &quot;no feedback found&quot; mean?</a></h3>
<p>If &quot;collaborative filtering&quot; tasks report no feedback found. It means there is no positive feedback in the database. The definition of positive feedback types and read feedback type is in the configuration file:</p>
<pre><code class="language-toml"># The feedback types for positive events.
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# The feedback types for read events.
read_feedback_types = [&quot;read&quot;]
</code></pre>
<p>If &quot;click-through rate prediction&quot; tasks report no feedback found. It means there is no negative feedback in the database. The negative feedback are these read feedback without positive feedback.</p>
<p>If you don't have any feedback, don't worry. There are fallback recommenders to handle cold-start problem.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
